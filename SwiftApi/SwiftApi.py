#
# Autogenerated by Thrift Compiler (0.9.1)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
from ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class Iface:
  def addItemToInventory(self, authString, playerName, item):
    """
    Add an item to a player's inventory

    @since 1.5

    @param authString
               The authentication hash

    @param playerName
               The name of the player

    @param item
               The item to add, in the form of an ItemStack

    @return boolean true on success, false on failure

    @throws EAuthException
                If the method call was not correctly authenticated

    @throws EDataException
                If the player was not found

    @throws org.apache.thrift.TException
                If something went wrong with Thrift

    Parameters:
     - authString
     - playerName
     - item
    """
    pass

  def addToWhitelist(self, authString, name):
    """
    Add a Player to the server's whitelist. The player can be offline, or
    be a player that has never played on this server before. If the player is
    already on the whitelist, this method does nothing.

    @param authString
               The authentication hash

    @param name
               The name of the player to add to the whitelist

    @return boolean true on success, false on failure

    @throws EAuthException
                If the method call was not correctly authenticated

    @throws EDataException
                If the player was not found

    @throws org.apache.thrift.TException
                If something went wrong with Thrift

    Parameters:
     - authString
     - name
    """
    pass

  def announce(self, authString, message):
    """
    Broadcasts a message to all players on the server

    @param authString
               The authentication hash

    @param message
               The message to send

    @return boolean true on success false on serious failure

    @throws EAuthException
                If the method call was not correctly authenticated

    @throws org.apache.thrift.TException
                If something went wrong with Thrift

    Parameters:
     - authString
     - message
    """
    pass

  def ban(self, authString, name):
    """
    Permanently ban a player from the server by name. The player can be
    offline, or have never played on this server before

    @param authString
               The authentication hash

    @param name
               The name of the player to ban

    @return boolean true on success false on failure

    @throws EAuthException
                If the method call was not correctly authenticated

    @throws EDataException
                If the player was not found

    @throws org.apache.thrift.TException
                If something went wrong with Thrift

    Parameters:
     - authString
     - name
    """
    pass

  def banIp(self, authString, ip):
    """
    Permanently ban a specific IP from connecting to this server

    @param authString
               The authentication hash

    @param ip
               The IP address to ban

    @return boolean true on success false on failure

    @throws EAuthException
                If the method call was not correctly authenticated

    @throws org.apache.thrift.TException
                If something went wrong with Thrift

    Parameters:
     - authString
     - ip
    """
    pass

  def deOp(self, authString, name, notifyPlayer):
    """
    Takes "op" (operator) privileges away from a player. If the player is
    already deopped, then this method does nothing

    @param authString
               The authentication hash

    @param name
               The player to deop

    @param notifyPlayer
               Whether or not to tell the player that they were deopped

    @throws TException
                If something thrifty went wrong

    @throws EAuthException
                If the method call was not correctly authenticated

    @throws EDataException
                If the Player was not found

    @return String the current bukkit version


    Parameters:
     - authString
     - name
     - notifyPlayer
    """
    pass

  def getBannedIps(self, authString):
    """
    Gets the IP addresses currently banned from joining this server

    @param authString
               The authentication hash

    @throws TException
                If something thrifty went wrong

    @throws EAuthException
                If the method call was not correctly authenticated

    @return List<String> The banned IPs


    Parameters:
     - authString
    """
    pass

  def getBannedPlayers(self, authString):
    """
    Gets the players currently banned from this server

    @param authString
               The authentication hash

    @throws TException
                If something thrifty went wrong

    @throws EAuthException
                If the method call was not correctly authenticated

    @return List<OfflinePlayer> The banned players


    Parameters:
     - authString
    """
    pass

  def getBukkitVersion(self, authString):
    """
    Get the current bukkit version

    @param authString
               The authentication hash

    @throws TException
                If something thrifty went wrong

    @throws EAuthException
                If the method call was not correctly authenticated

    @return String the current bukkit version


    Parameters:
     - authString
    """
    pass

  def getConsoleMessages(self, authString, since):
    """
    Get the last 500 console messages or console messages since a given timestamp (up to 500)

    @param authString
               The authentication hash

    @param since
               A unix timestamp (with milliseconds). This will limit the results
    		  to console lines that were out output after the given time

    @return boolean true on success false on serious failure

    @throws EAuthException
                If the method call was not correctly authenticated

    @throws org.apache.thrift.TException
                If something went wrong with Thrift

    Parameters:
     - authString
     - since
    """
    pass

  def getFileContents(self, authString, fileName):
    """
    Gets the contents of a file.

    @param authString
               The authentication hash

    @param fileName
               The file to get. The fileName is relative to the server
               root. This method cannot get the contents of any file
               outside the server root.

    @throws TException
                If something thrifty went wrong

    @throws EAuthException
                If the method call was not correctly authenticated

    @throws EDataException
                If the file could not be read or does not exist

    @return string the contents of the file


    Parameters:
     - authString
     - fileName
    """
    pass

  def getOfflinePlayer(self, authString, name):
    """
    Get an offline player. This method will always return an
    OfflinePlayer object, even if the requested player has never played
    before.

    The "hasPlayedBefore" property can be checked to determine if the
    requested player has ever played on this particular server before

    @param authString
               The authentication hash

    @param name
               The player to get

    @throws TException
                If something thrifty went wrong

    @throws EAuthException
                If the method call was not correctly authenticated

    @throws EDataException
                If the player could not be found

    @return OfflinePlayer the requested player.


    Parameters:
     - authString
     - name
    """
    pass

  def getOfflinePlayers(self, authString):
    """
    Gets a list of all players who have ever played on this server

    @param authString
               The authentication hash

    @throws TException
                If something thrifty went wrong

    @throws EAuthException
                If the method call was not correctly authenticated

    @return List<OfflinePlayer> A list of all players who have ever
            played on this server


    Parameters:
     - authString
    """
    pass

  def getOps(self, authString):
    """
    Gets a list of all players who are Opped on this server

    @param authString
               The authentication hash

    @throws TException
                If something thrifty went wrong

    @throws EAuthException
                If the method call was not correctly authenticated

    @return List<OfflinePlayer> A list of all players who are opped
            on this server


    Parameters:
     - authString
    """
    pass

  def getPlayer(self, authString, name):
    """
    Get a player by name. Throws an EDataException if the player is
    offline, or doesn't exist

    @param authString
               The authentication hash

    @param name
               The name of the player to try and get

    @throws TException
                If something thrifty went wrong

    @throws EAuthException
                If the method call was not correctly authenticated

    @throws EDataException
                If the player is not online, or does not exist

    @return Player The requested player. If the player could not be
            found, and EDataException is thrown
    @see org.phybros.thrift.SwiftApi.Iface#getPlugins(java.lang.String)

    Parameters:
     - authString
     - name
    """
    pass

  def getPlayers(self, authString):
    """
    Get all online Players

    @param authString
               The authentication hash

    @throws TException
                If something thrifty went wrong

    @throws EAuthException
                If the method call was not correctly authenticated

    @return List<Player> A list of all currently online players

    Parameters:
     - authString
    """
    pass

  def getPlugin(self, authString, name):
    """
    Get a loaded server plugin by name

    @param authString
               The authentication hash

    @param name
               The name of the plugin to try and get

    @throws TException
                If something thrifty went wrong

    @throws EDataException
                If the requested plugin was not found

    @throws EAuthException
                If the method call was not correctly authenticated

    @return Plugin The plugin


    Parameters:
     - authString
     - name
    """
    pass

  def getPlugins(self, authString):
    """
    This method returns a list of all the currently loaded plugins on the
    server.

    @param authString
               The authentication hash

    @throws TException
                If something thrifty went wrong

    @throws EAuthException
                If the method call was not correctly authenticated

    @return List<Plugin> A list of the plugins on the server


    Parameters:
     - authString
    """
    pass

  def getServer(self, authString):
    """
    Get the current server. This object contains a large amount of information
    about the server including player and plugin information, as well as configuration
    information.

    @param authString
               The authentication hash

    @throws TException
    		  If something thrifty went wrong

    @throws EAuthException
    		  If the method call was not correctly authenticated

    @return Server An object containing server information


    Parameters:
     - authString
    """
    pass

  def getServerVersion(self, authString):
    """
    Get the current server version

    @param authString
               The authentication hash

    @throws TException
                If something thrifty went wrong

    @throws EAuthException
                If the method call was not correctly authenticated

    @return String the version of the server


    Parameters:
     - authString
    """
    pass

  def getWhitelist(self, authString):
    """
    Gets all whitelisted players

    @param authString
               The authentication hash

    @throws TException
                If something thrifty went wrong

    @throws EAuthException
                If the method call was not correctly authenticated

    @return List<OfflinePlayer> The players on the server's whitelist


    Parameters:
     - authString
    """
    pass

  def getWorld(self, authString, worldName):
    """
    Gets a specific world by name

    @param authString
               The authentication hash

    @param worldName
               The name of the World to get

    @throws TException
                If something thrifty went wrong

    @throws EAuthException
                If the method call was not correctly authenticated

    @throws EDataException
                If the requested world could not be found

    @return World The requested world


    Parameters:
     - authString
     - worldName
    """
    pass

  def getWorlds(self, authString):
    """
    Gets all the worlds on the server

    @param authString
               The authentication hash

    @throws TException
                If something thrifty went wrong

    @throws EAuthException
                If the method call was not correctly authenticated

    @return List<World> the worlds on the server


    Parameters:
     - authString
    """
    pass

  def installPlugin(self, authString, downloadUrl, md5):
    """
    This method will download and install (copy/unzip) a plugin from a given URL
    onto the server.

    @param authString
               The authentication hash

    @param downloadUrl
               The URL of the file to be downloaded

    @param md5
               The md5 hash of the file that is being downloaded

    @return boolean true on success false on failure

    @throws EAuthException
                If the method call was not correctly authenticated

    @throws EDataException
                If something went wrong during the file download, or the
                computed hash does not match the provided hash or the
                requested plugin could not be found.

    @throws org.apache.thrift.TException
                If something went wrong with Thrift

    Parameters:
     - authString
     - downloadUrl
     - md5
    """
    pass

  def kick(self, authString, name, message):
    """
    Kick a currently online Player from the server with a specific custom
    message

    @param authString
               The authentication hash

    @param name
               The name of the player to kick

    @param message
               The message to send to the player after they have been
               kicked

    @return boolean true on success false on failure

    @throws EAuthException
                If the method call was not correctly authenticated

    @throws EDataException
                If the player is not currently online

    @throws org.apache.thrift.TException
                If something went wrong with Thrift

    Parameters:
     - authString
     - name
     - message
    """
    pass

  def op(self, authString, name, notifyPlayer):
    """
    Makes a player "op" (operator). If the player is already op, then
    this method does nothing

    @param authString
               The authentication hash

    @param name
               The name of the player to op
               
    @throws TException
                If something thrifty went wrong

    @throws EAuthException
                If the method call was not correctly authenticated

    @throws EDataException
                If the Player was not found

    @return String the current bukkit version


    Parameters:
     - authString
     - name
     - notifyPlayer
    """
    pass

  def ping(self, authString):
    """
    Just a keepalive method to test authentication in clients

    @param authString
               The authentication hash

    @return boolean true on success false on serious failure

    @throws EAuthException
                If the method call was not correctly authenticated

    @throws org.apache.thrift.TException
                If something went wrong with Thrift

    Parameters:
     - authString
    """
    pass

  def reloadServer(self, authString):
    """
    Reloads the server. This call does not send a response (for obvious reasons)

    @param authString
               The authentication hash

    Parameters:
     - authString
    """
    pass

  def removeInventoryItem(self, authString, playerName, itemIndex):
    """
    Removes an item from a player's inventory

    @since 1.5

    @param authString
               The authentication hash

    @param playerName
               The name of the player

    @param itemIndex
               The 0-based index of the item being removed

    @return boolean true on success, false on failure

    @throws EAuthException
                If the method call was not correctly authenticated

    @throws EDataException
                If the player was not found

    @throws org.apache.thrift.TException
                If something went wrong with Thrift

    Parameters:
     - authString
     - playerName
     - itemIndex
    """
    pass

  def removeFromWhitelist(self, authString, name):
    """
    Remove a Player from the server's whitelist. The player can be offline, or
    be a player that has never played on this server before. If the player is not
    already on the whitelist, this method does nothing.

    @param authString
               The authentication hash

    @param name
               The name of the player to remove from the whitelist

    @return boolean true on success, false on failure

    @throws EAuthException
                If the method call was not correctly authenticated

    @throws EDataException
                If the player was not found

    @throws org.apache.thrift.TException
                If something went wrong with Thrift

    Parameters:
     - authString
     - name
    """
    pass

  def replacePlugin(self, authString, pluginName, downloadUrl, md5):
    """
    This method will replace a given plugin's .jar file with a new
    version downloaded from the internet. The old .jar file will be moved
    to a folder inside the SwiftApi Plugin's data folder called
    "oldPlugins/" under the name
    <PluginName>_<Version>-<Timestamp>.jar.old

    @param authString
               The authentication hash

    @param pluginName
               The name of the plugin to replace

    @param downloadUrl
               The URL of the file to be downloaded

    @param md5
               The md5 hash of the file that is being downloaded

    @return boolean true on success false on failure

    @throws EAuthException
                If the method call was not correctly authenticated

    @throws EDataException
                If something went wrong during the file download, or the
                computed hash does not match the provided hash or the
                requested plugin could not be found.

    @throws org.apache.thrift.TException
                If something went wrong with Thrift

    Parameters:
     - authString
     - pluginName
     - downloadUrl
     - md5
    """
    pass

  def runConsoleCommand(self, authString, command):
    """
    Executes a command as if you were to type it directly into the console
    (no need for leading forward-slash "/").

    @param authString
               The authentication hash

    @return boolean true on success false on serious failure

    @throws EAuthException
                If the method call was not correctly authenticated

    @throws org.apache.thrift.TException
                If something went wrong with Thrift

    Parameters:
     - authString
     - command
    """
    pass

  def saveWorld(self, authString, worldName):
    """
    Saves the specified world to disk

    @param authString
               The authentication hash

    @param worldName
               The name of the world to save

    @return boolean true on success false on serious failure

    @throws EAuthException
                If the method call was not correctly authenticated

    @throws EDataException
                If the specified world could not be found

    @throws org.apache.thrift.TException
                If something went wrong with Thrift

    Parameters:
     - authString
     - worldName
    """
    pass

  def setFileContents(self, authString, fileName, fileContents):
    """
    Sets the contents of a file.

    @param authString
               The authentication hash

    @param fileName
               The file to set. The fileName is relative to /plugins. This
    		  method cannot set the contents of any file outside /plugins.

    @throws TException
                If something thrifty went wrong

    @throws EAuthException
                If the method call was not correctly authenticated

    @throws EDataException
                If the file could not be opened or does not exist

    @return bool true on success, else false


    Parameters:
     - authString
     - fileName
     - fileContents
    """
    pass

  def setGameMode(self, authString, name, mode):
    """
    Sets the gamemode of a player

    @param authString
               The authentication hash

    @param name
               The name of the player

    @param mode
               The GameMode to set the player to

    @throws TException
                If something thrifty went wrong

    @throws EAuthException
                If the method call was not correctly authenticated

    @throws EDataException
                If the Player was not found

    @return String the current bukkit version


    Parameters:
     - authString
     - name
     - mode
    """
    pass

  def setPvp(self, authString, worldName, isPvp):
    """
    Set's the isPVP property on the specified world

    @param authString
               The authentication hash

    @param worldName
               The name of the world to set the pvp flag for

    @param isPvp
               The value to set the isPVP property to

    @return boolean true on success false on serious failure

    @throws EAuthException
                If the method call was not correctly authenticated

    @throws EDataException
                If the specified world could not be found

    @throws org.apache.thrift.TException
                If something went wrong with Thrift

    Parameters:
     - authString
     - worldName
     - isPvp
    """
    pass

  def setStorm(self, authString, worldName, hasStorm):
    """
    Set's the hasStorm property on the specified world (i.e. makes it rain)

    @param authString
               The authentication hash

    @param worldName
               The name of the world to set the storm for

    @param hasStorm
               The value to set the storm property to

    @return boolean true on success false on serious failure

    @throws EAuthException
                If the method call was not correctly authenticated

    @throws EDataException
                If the specified world could not be found

    @throws org.apache.thrift.TException
                If something went wrong with Thrift

    Parameters:
     - authString
     - worldName
     - hasStorm
    """
    pass

  def setThundering(self, authString, worldName, isThundering):
    """
    Set's the isThundering property on the specified world

    @param authString
               The authentication hash

    @param worldName
               The name of the world to set the storm for

    @param isThundering
               The value to set the isThundering property to

    @return boolean true on success false on serious failure

    @throws EAuthException
                If the method call was not correctly authenticated

    @throws EDataException
                If the specified world could not be found

    @throws org.apache.thrift.TException
                If something went wrong with Thrift

    Parameters:
     - authString
     - worldName
     - isThundering
    """
    pass

  def setWorldTime(self, authString, worldName, time):
    """
    Sets the time on the specified world or all worlds if a
    blank world name is specified.

    @param authString
               The authentication hash

    @param worldName
               The name of the world to set the time for. If a blank
    		  world name is specified, the time is set for all worlds.

    @param time
               The value to set the world time

    @return boolean true on success false on serious failure

    @throws EAuthException
                If the method call was not correctly authenticated

    @throws EDataException
                If the specified world could not be found

    @throws org.apache.thrift.TException
                If something went wrong with Thrift

    Parameters:
     - authString
     - worldName
     - time
    """
    pass

  def unBan(self, authString, name):
    """
    Un ban a specific player

    @param authString
               The authentication hash

    @param name
               The name of the player to unban

    @return boolean true on success false on failure

    @throws EAuthException
                If the method call was not correctly authenticated

    @throws EDataException
                If the player was not found

    @throws org.apache.thrift.TException
                If something went wrong with Thrift

    Parameters:
     - authString
     - name
    """
    pass

  def unBanIp(self, authString, ip):
    """
    Un ban a specific IP from connecting to this server

    @param authString
               The authentication hash

    @param ip
               The IP to unban

    @return boolean true on success false on failure

    @throws EAuthException
                If the method call was not correctly authenticated

    @throws org.apache.thrift.TException
                If something went wrong with Thrift

    Parameters:
     - authString
     - ip
    """
    pass

  def updateInventoryItem(self, authString, playerName, item, itemIndex):
    """
    Replaces an item in the player's inventory with the supplied one

    @since 1.5

    @param authString
               The authentication hash

    @param playerName
               The name of the player

    @param item
               The item that will replace the item specified by itemIndex, in the form of an ItemStack

    @param itemIndex
               The 0-based index of which item to replace in the inventory

    @return boolean true on success, false on failure

    @throws EAuthException
                If the method call was not correctly authenticated

    @throws EDataException
                If the player was not found

    @throws org.apache.thrift.TException
                If something went wrong with Thrift

    Parameters:
     - authString
     - playerName
     - item
     - itemIndex
    """
    pass


class Client(Iface):
  def __init__(self, iprot, oprot=None):
    self._iprot = self._oprot = iprot
    if oprot is not None:
      self._oprot = oprot
    self._seqid = 0

  def addItemToInventory(self, authString, playerName, item):
    """
    Add an item to a player's inventory

    @since 1.5

    @param authString
               The authentication hash

    @param playerName
               The name of the player

    @param item
               The item to add, in the form of an ItemStack

    @return boolean true on success, false on failure

    @throws EAuthException
                If the method call was not correctly authenticated

    @throws EDataException
                If the player was not found

    @throws org.apache.thrift.TException
                If something went wrong with Thrift

    Parameters:
     - authString
     - playerName
     - item
    """
    self.send_addItemToInventory(authString, playerName, item)
    return self.recv_addItemToInventory()

  def send_addItemToInventory(self, authString, playerName, item):
    self._oprot.writeMessageBegin('addItemToInventory', TMessageType.CALL, self._seqid)
    args = addItemToInventory_args()
    args.authString = authString
    args.playerName = playerName
    args.item = item
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_addItemToInventory(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = addItemToInventory_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.aex is not None:
      raise result.aex
    if result.dex is not None:
      raise result.dex
    raise TApplicationException(TApplicationException.MISSING_RESULT, "addItemToInventory failed: unknown result");

  def addToWhitelist(self, authString, name):
    """
    Add a Player to the server's whitelist. The player can be offline, or
    be a player that has never played on this server before. If the player is
    already on the whitelist, this method does nothing.

    @param authString
               The authentication hash

    @param name
               The name of the player to add to the whitelist

    @return boolean true on success, false on failure

    @throws EAuthException
                If the method call was not correctly authenticated

    @throws EDataException
                If the player was not found

    @throws org.apache.thrift.TException
                If something went wrong with Thrift

    Parameters:
     - authString
     - name
    """
    self.send_addToWhitelist(authString, name)
    return self.recv_addToWhitelist()

  def send_addToWhitelist(self, authString, name):
    self._oprot.writeMessageBegin('addToWhitelist', TMessageType.CALL, self._seqid)
    args = addToWhitelist_args()
    args.authString = authString
    args.name = name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_addToWhitelist(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = addToWhitelist_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.aex is not None:
      raise result.aex
    if result.dex is not None:
      raise result.dex
    raise TApplicationException(TApplicationException.MISSING_RESULT, "addToWhitelist failed: unknown result");

  def announce(self, authString, message):
    """
    Broadcasts a message to all players on the server

    @param authString
               The authentication hash

    @param message
               The message to send

    @return boolean true on success false on serious failure

    @throws EAuthException
                If the method call was not correctly authenticated

    @throws org.apache.thrift.TException
                If something went wrong with Thrift

    Parameters:
     - authString
     - message
    """
    self.send_announce(authString, message)
    return self.recv_announce()

  def send_announce(self, authString, message):
    self._oprot.writeMessageBegin('announce', TMessageType.CALL, self._seqid)
    args = announce_args()
    args.authString = authString
    args.message = message
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_announce(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = announce_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.aex is not None:
      raise result.aex
    raise TApplicationException(TApplicationException.MISSING_RESULT, "announce failed: unknown result");

  def ban(self, authString, name):
    """
    Permanently ban a player from the server by name. The player can be
    offline, or have never played on this server before

    @param authString
               The authentication hash

    @param name
               The name of the player to ban

    @return boolean true on success false on failure

    @throws EAuthException
                If the method call was not correctly authenticated

    @throws EDataException
                If the player was not found

    @throws org.apache.thrift.TException
                If something went wrong with Thrift

    Parameters:
     - authString
     - name
    """
    self.send_ban(authString, name)
    return self.recv_ban()

  def send_ban(self, authString, name):
    self._oprot.writeMessageBegin('ban', TMessageType.CALL, self._seqid)
    args = ban_args()
    args.authString = authString
    args.name = name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_ban(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = ban_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.aex is not None:
      raise result.aex
    if result.dex is not None:
      raise result.dex
    raise TApplicationException(TApplicationException.MISSING_RESULT, "ban failed: unknown result");

  def banIp(self, authString, ip):
    """
    Permanently ban a specific IP from connecting to this server

    @param authString
               The authentication hash

    @param ip
               The IP address to ban

    @return boolean true on success false on failure

    @throws EAuthException
                If the method call was not correctly authenticated

    @throws org.apache.thrift.TException
                If something went wrong with Thrift

    Parameters:
     - authString
     - ip
    """
    self.send_banIp(authString, ip)
    return self.recv_banIp()

  def send_banIp(self, authString, ip):
    self._oprot.writeMessageBegin('banIp', TMessageType.CALL, self._seqid)
    args = banIp_args()
    args.authString = authString
    args.ip = ip
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_banIp(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = banIp_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.aex is not None:
      raise result.aex
    raise TApplicationException(TApplicationException.MISSING_RESULT, "banIp failed: unknown result");

  def deOp(self, authString, name, notifyPlayer):
    """
    Takes "op" (operator) privileges away from a player. If the player is
    already deopped, then this method does nothing

    @param authString
               The authentication hash

    @param name
               The player to deop

    @param notifyPlayer
               Whether or not to tell the player that they were deopped

    @throws TException
                If something thrifty went wrong

    @throws EAuthException
                If the method call was not correctly authenticated

    @throws EDataException
                If the Player was not found

    @return String the current bukkit version


    Parameters:
     - authString
     - name
     - notifyPlayer
    """
    self.send_deOp(authString, name, notifyPlayer)
    return self.recv_deOp()

  def send_deOp(self, authString, name, notifyPlayer):
    self._oprot.writeMessageBegin('deOp', TMessageType.CALL, self._seqid)
    args = deOp_args()
    args.authString = authString
    args.name = name
    args.notifyPlayer = notifyPlayer
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_deOp(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = deOp_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.aex is not None:
      raise result.aex
    if result.dex is not None:
      raise result.dex
    raise TApplicationException(TApplicationException.MISSING_RESULT, "deOp failed: unknown result");

  def getBannedIps(self, authString):
    """
    Gets the IP addresses currently banned from joining this server

    @param authString
               The authentication hash

    @throws TException
                If something thrifty went wrong

    @throws EAuthException
                If the method call was not correctly authenticated

    @return List<String> The banned IPs


    Parameters:
     - authString
    """
    self.send_getBannedIps(authString)
    return self.recv_getBannedIps()

  def send_getBannedIps(self, authString):
    self._oprot.writeMessageBegin('getBannedIps', TMessageType.CALL, self._seqid)
    args = getBannedIps_args()
    args.authString = authString
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getBannedIps(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getBannedIps_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.aex is not None:
      raise result.aex
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getBannedIps failed: unknown result");

  def getBannedPlayers(self, authString):
    """
    Gets the players currently banned from this server

    @param authString
               The authentication hash

    @throws TException
                If something thrifty went wrong

    @throws EAuthException
                If the method call was not correctly authenticated

    @return List<OfflinePlayer> The banned players


    Parameters:
     - authString
    """
    self.send_getBannedPlayers(authString)
    return self.recv_getBannedPlayers()

  def send_getBannedPlayers(self, authString):
    self._oprot.writeMessageBegin('getBannedPlayers', TMessageType.CALL, self._seqid)
    args = getBannedPlayers_args()
    args.authString = authString
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getBannedPlayers(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getBannedPlayers_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.aex is not None:
      raise result.aex
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getBannedPlayers failed: unknown result");

  def getBukkitVersion(self, authString):
    """
    Get the current bukkit version

    @param authString
               The authentication hash

    @throws TException
                If something thrifty went wrong

    @throws EAuthException
                If the method call was not correctly authenticated

    @return String the current bukkit version


    Parameters:
     - authString
    """
    self.send_getBukkitVersion(authString)
    return self.recv_getBukkitVersion()

  def send_getBukkitVersion(self, authString):
    self._oprot.writeMessageBegin('getBukkitVersion', TMessageType.CALL, self._seqid)
    args = getBukkitVersion_args()
    args.authString = authString
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getBukkitVersion(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getBukkitVersion_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.aex is not None:
      raise result.aex
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getBukkitVersion failed: unknown result");

  def getConsoleMessages(self, authString, since):
    """
    Get the last 500 console messages or console messages since a given timestamp (up to 500)

    @param authString
               The authentication hash

    @param since
               A unix timestamp (with milliseconds). This will limit the results
    		  to console lines that were out output after the given time

    @return boolean true on success false on serious failure

    @throws EAuthException
                If the method call was not correctly authenticated

    @throws org.apache.thrift.TException
                If something went wrong with Thrift

    Parameters:
     - authString
     - since
    """
    self.send_getConsoleMessages(authString, since)
    return self.recv_getConsoleMessages()

  def send_getConsoleMessages(self, authString, since):
    self._oprot.writeMessageBegin('getConsoleMessages', TMessageType.CALL, self._seqid)
    args = getConsoleMessages_args()
    args.authString = authString
    args.since = since
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getConsoleMessages(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getConsoleMessages_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.aex is not None:
      raise result.aex
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getConsoleMessages failed: unknown result");

  def getFileContents(self, authString, fileName):
    """
    Gets the contents of a file.

    @param authString
               The authentication hash

    @param fileName
               The file to get. The fileName is relative to the server
               root. This method cannot get the contents of any file
               outside the server root.

    @throws TException
                If something thrifty went wrong

    @throws EAuthException
                If the method call was not correctly authenticated

    @throws EDataException
                If the file could not be read or does not exist

    @return string the contents of the file


    Parameters:
     - authString
     - fileName
    """
    self.send_getFileContents(authString, fileName)
    return self.recv_getFileContents()

  def send_getFileContents(self, authString, fileName):
    self._oprot.writeMessageBegin('getFileContents', TMessageType.CALL, self._seqid)
    args = getFileContents_args()
    args.authString = authString
    args.fileName = fileName
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getFileContents(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getFileContents_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.aex is not None:
      raise result.aex
    if result.dex is not None:
      raise result.dex
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getFileContents failed: unknown result");

  def getOfflinePlayer(self, authString, name):
    """
    Get an offline player. This method will always return an
    OfflinePlayer object, even if the requested player has never played
    before.

    The "hasPlayedBefore" property can be checked to determine if the
    requested player has ever played on this particular server before

    @param authString
               The authentication hash

    @param name
               The player to get

    @throws TException
                If something thrifty went wrong

    @throws EAuthException
                If the method call was not correctly authenticated

    @throws EDataException
                If the player could not be found

    @return OfflinePlayer the requested player.


    Parameters:
     - authString
     - name
    """
    self.send_getOfflinePlayer(authString, name)
    return self.recv_getOfflinePlayer()

  def send_getOfflinePlayer(self, authString, name):
    self._oprot.writeMessageBegin('getOfflinePlayer', TMessageType.CALL, self._seqid)
    args = getOfflinePlayer_args()
    args.authString = authString
    args.name = name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getOfflinePlayer(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getOfflinePlayer_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.aex is not None:
      raise result.aex
    if result.dex is not None:
      raise result.dex
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getOfflinePlayer failed: unknown result");

  def getOfflinePlayers(self, authString):
    """
    Gets a list of all players who have ever played on this server

    @param authString
               The authentication hash

    @throws TException
                If something thrifty went wrong

    @throws EAuthException
                If the method call was not correctly authenticated

    @return List<OfflinePlayer> A list of all players who have ever
            played on this server


    Parameters:
     - authString
    """
    self.send_getOfflinePlayers(authString)
    return self.recv_getOfflinePlayers()

  def send_getOfflinePlayers(self, authString):
    self._oprot.writeMessageBegin('getOfflinePlayers', TMessageType.CALL, self._seqid)
    args = getOfflinePlayers_args()
    args.authString = authString
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getOfflinePlayers(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getOfflinePlayers_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.aex is not None:
      raise result.aex
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getOfflinePlayers failed: unknown result");

  def getOps(self, authString):
    """
    Gets a list of all players who are Opped on this server

    @param authString
               The authentication hash

    @throws TException
                If something thrifty went wrong

    @throws EAuthException
                If the method call was not correctly authenticated

    @return List<OfflinePlayer> A list of all players who are opped
            on this server


    Parameters:
     - authString
    """
    self.send_getOps(authString)
    return self.recv_getOps()

  def send_getOps(self, authString):
    self._oprot.writeMessageBegin('getOps', TMessageType.CALL, self._seqid)
    args = getOps_args()
    args.authString = authString
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getOps(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getOps_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.aex is not None:
      raise result.aex
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getOps failed: unknown result");

  def getPlayer(self, authString, name):
    """
    Get a player by name. Throws an EDataException if the player is
    offline, or doesn't exist

    @param authString
               The authentication hash

    @param name
               The name of the player to try and get

    @throws TException
                If something thrifty went wrong

    @throws EAuthException
                If the method call was not correctly authenticated

    @throws EDataException
                If the player is not online, or does not exist

    @return Player The requested player. If the player could not be
            found, and EDataException is thrown
    @see org.phybros.thrift.SwiftApi.Iface#getPlugins(java.lang.String)

    Parameters:
     - authString
     - name
    """
    self.send_getPlayer(authString, name)
    return self.recv_getPlayer()

  def send_getPlayer(self, authString, name):
    self._oprot.writeMessageBegin('getPlayer', TMessageType.CALL, self._seqid)
    args = getPlayer_args()
    args.authString = authString
    args.name = name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getPlayer(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getPlayer_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.aex is not None:
      raise result.aex
    if result.dex is not None:
      raise result.dex
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getPlayer failed: unknown result");

  def getPlayers(self, authString):
    """
    Get all online Players

    @param authString
               The authentication hash

    @throws TException
                If something thrifty went wrong

    @throws EAuthException
                If the method call was not correctly authenticated

    @return List<Player> A list of all currently online players

    Parameters:
     - authString
    """
    self.send_getPlayers(authString)
    return self.recv_getPlayers()

  def send_getPlayers(self, authString):
    self._oprot.writeMessageBegin('getPlayers', TMessageType.CALL, self._seqid)
    args = getPlayers_args()
    args.authString = authString
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getPlayers(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getPlayers_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.aex is not None:
      raise result.aex
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getPlayers failed: unknown result");

  def getPlugin(self, authString, name):
    """
    Get a loaded server plugin by name

    @param authString
               The authentication hash

    @param name
               The name of the plugin to try and get

    @throws TException
                If something thrifty went wrong

    @throws EDataException
                If the requested plugin was not found

    @throws EAuthException
                If the method call was not correctly authenticated

    @return Plugin The plugin


    Parameters:
     - authString
     - name
    """
    self.send_getPlugin(authString, name)
    return self.recv_getPlugin()

  def send_getPlugin(self, authString, name):
    self._oprot.writeMessageBegin('getPlugin', TMessageType.CALL, self._seqid)
    args = getPlugin_args()
    args.authString = authString
    args.name = name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getPlugin(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getPlugin_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.aex is not None:
      raise result.aex
    if result.dex is not None:
      raise result.dex
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getPlugin failed: unknown result");

  def getPlugins(self, authString):
    """
    This method returns a list of all the currently loaded plugins on the
    server.

    @param authString
               The authentication hash

    @throws TException
                If something thrifty went wrong

    @throws EAuthException
                If the method call was not correctly authenticated

    @return List<Plugin> A list of the plugins on the server


    Parameters:
     - authString
    """
    self.send_getPlugins(authString)
    return self.recv_getPlugins()

  def send_getPlugins(self, authString):
    self._oprot.writeMessageBegin('getPlugins', TMessageType.CALL, self._seqid)
    args = getPlugins_args()
    args.authString = authString
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getPlugins(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getPlugins_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.aex is not None:
      raise result.aex
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getPlugins failed: unknown result");

  def getServer(self, authString):
    """
    Get the current server. This object contains a large amount of information
    about the server including player and plugin information, as well as configuration
    information.

    @param authString
               The authentication hash

    @throws TException
    		  If something thrifty went wrong

    @throws EAuthException
    		  If the method call was not correctly authenticated

    @return Server An object containing server information


    Parameters:
     - authString
    """
    self.send_getServer(authString)
    return self.recv_getServer()

  def send_getServer(self, authString):
    self._oprot.writeMessageBegin('getServer', TMessageType.CALL, self._seqid)
    args = getServer_args()
    args.authString = authString
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getServer(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getServer_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.aex is not None:
      raise result.aex
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getServer failed: unknown result");

  def getServerVersion(self, authString):
    """
    Get the current server version

    @param authString
               The authentication hash

    @throws TException
                If something thrifty went wrong

    @throws EAuthException
                If the method call was not correctly authenticated

    @return String the version of the server


    Parameters:
     - authString
    """
    self.send_getServerVersion(authString)
    return self.recv_getServerVersion()

  def send_getServerVersion(self, authString):
    self._oprot.writeMessageBegin('getServerVersion', TMessageType.CALL, self._seqid)
    args = getServerVersion_args()
    args.authString = authString
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getServerVersion(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getServerVersion_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.aex is not None:
      raise result.aex
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getServerVersion failed: unknown result");

  def getWhitelist(self, authString):
    """
    Gets all whitelisted players

    @param authString
               The authentication hash

    @throws TException
                If something thrifty went wrong

    @throws EAuthException
                If the method call was not correctly authenticated

    @return List<OfflinePlayer> The players on the server's whitelist


    Parameters:
     - authString
    """
    self.send_getWhitelist(authString)
    return self.recv_getWhitelist()

  def send_getWhitelist(self, authString):
    self._oprot.writeMessageBegin('getWhitelist', TMessageType.CALL, self._seqid)
    args = getWhitelist_args()
    args.authString = authString
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getWhitelist(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getWhitelist_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.aex is not None:
      raise result.aex
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getWhitelist failed: unknown result");

  def getWorld(self, authString, worldName):
    """
    Gets a specific world by name

    @param authString
               The authentication hash

    @param worldName
               The name of the World to get

    @throws TException
                If something thrifty went wrong

    @throws EAuthException
                If the method call was not correctly authenticated

    @throws EDataException
                If the requested world could not be found

    @return World The requested world


    Parameters:
     - authString
     - worldName
    """
    self.send_getWorld(authString, worldName)
    return self.recv_getWorld()

  def send_getWorld(self, authString, worldName):
    self._oprot.writeMessageBegin('getWorld', TMessageType.CALL, self._seqid)
    args = getWorld_args()
    args.authString = authString
    args.worldName = worldName
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getWorld(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getWorld_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.aex is not None:
      raise result.aex
    if result.dex is not None:
      raise result.dex
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getWorld failed: unknown result");

  def getWorlds(self, authString):
    """
    Gets all the worlds on the server

    @param authString
               The authentication hash

    @throws TException
                If something thrifty went wrong

    @throws EAuthException
                If the method call was not correctly authenticated

    @return List<World> the worlds on the server


    Parameters:
     - authString
    """
    self.send_getWorlds(authString)
    return self.recv_getWorlds()

  def send_getWorlds(self, authString):
    self._oprot.writeMessageBegin('getWorlds', TMessageType.CALL, self._seqid)
    args = getWorlds_args()
    args.authString = authString
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getWorlds(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getWorlds_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.aex is not None:
      raise result.aex
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getWorlds failed: unknown result");

  def installPlugin(self, authString, downloadUrl, md5):
    """
    This method will download and install (copy/unzip) a plugin from a given URL
    onto the server.

    @param authString
               The authentication hash

    @param downloadUrl
               The URL of the file to be downloaded

    @param md5
               The md5 hash of the file that is being downloaded

    @return boolean true on success false on failure

    @throws EAuthException
                If the method call was not correctly authenticated

    @throws EDataException
                If something went wrong during the file download, or the
                computed hash does not match the provided hash or the
                requested plugin could not be found.

    @throws org.apache.thrift.TException
                If something went wrong with Thrift

    Parameters:
     - authString
     - downloadUrl
     - md5
    """
    self.send_installPlugin(authString, downloadUrl, md5)
    return self.recv_installPlugin()

  def send_installPlugin(self, authString, downloadUrl, md5):
    self._oprot.writeMessageBegin('installPlugin', TMessageType.CALL, self._seqid)
    args = installPlugin_args()
    args.authString = authString
    args.downloadUrl = downloadUrl
    args.md5 = md5
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_installPlugin(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = installPlugin_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.aex is not None:
      raise result.aex
    if result.dex is not None:
      raise result.dex
    raise TApplicationException(TApplicationException.MISSING_RESULT, "installPlugin failed: unknown result");

  def kick(self, authString, name, message):
    """
    Kick a currently online Player from the server with a specific custom
    message

    @param authString
               The authentication hash

    @param name
               The name of the player to kick

    @param message
               The message to send to the player after they have been
               kicked

    @return boolean true on success false on failure

    @throws EAuthException
                If the method call was not correctly authenticated

    @throws EDataException
                If the player is not currently online

    @throws org.apache.thrift.TException
                If something went wrong with Thrift

    Parameters:
     - authString
     - name
     - message
    """
    self.send_kick(authString, name, message)
    return self.recv_kick()

  def send_kick(self, authString, name, message):
    self._oprot.writeMessageBegin('kick', TMessageType.CALL, self._seqid)
    args = kick_args()
    args.authString = authString
    args.name = name
    args.message = message
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_kick(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = kick_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.aex is not None:
      raise result.aex
    if result.dex is not None:
      raise result.dex
    raise TApplicationException(TApplicationException.MISSING_RESULT, "kick failed: unknown result");

  def op(self, authString, name, notifyPlayer):
    """
    Makes a player "op" (operator). If the player is already op, then
    this method does nothing

    @param authString
               The authentication hash

    @param name
               The name of the player to op
               
    @throws TException
                If something thrifty went wrong

    @throws EAuthException
                If the method call was not correctly authenticated

    @throws EDataException
                If the Player was not found

    @return String the current bukkit version


    Parameters:
     - authString
     - name
     - notifyPlayer
    """
    self.send_op(authString, name, notifyPlayer)
    return self.recv_op()

  def send_op(self, authString, name, notifyPlayer):
    self._oprot.writeMessageBegin('op', TMessageType.CALL, self._seqid)
    args = op_args()
    args.authString = authString
    args.name = name
    args.notifyPlayer = notifyPlayer
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_op(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = op_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.aex is not None:
      raise result.aex
    if result.dex is not None:
      raise result.dex
    raise TApplicationException(TApplicationException.MISSING_RESULT, "op failed: unknown result");

  def ping(self, authString):
    """
    Just a keepalive method to test authentication in clients

    @param authString
               The authentication hash

    @return boolean true on success false on serious failure

    @throws EAuthException
                If the method call was not correctly authenticated

    @throws org.apache.thrift.TException
                If something went wrong with Thrift

    Parameters:
     - authString
    """
    self.send_ping(authString)
    return self.recv_ping()

  def send_ping(self, authString):
    self._oprot.writeMessageBegin('ping', TMessageType.CALL, self._seqid)
    args = ping_args()
    args.authString = authString
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_ping(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = ping_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.aex is not None:
      raise result.aex
    raise TApplicationException(TApplicationException.MISSING_RESULT, "ping failed: unknown result");

  def reloadServer(self, authString):
    """
    Reloads the server. This call does not send a response (for obvious reasons)

    @param authString
               The authentication hash

    Parameters:
     - authString
    """
    self.send_reloadServer(authString)

  def send_reloadServer(self, authString):
    self._oprot.writeMessageBegin('reloadServer', TMessageType.CALL, self._seqid)
    args = reloadServer_args()
    args.authString = authString
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()
  def removeInventoryItem(self, authString, playerName, itemIndex):
    """
    Removes an item from a player's inventory

    @since 1.5

    @param authString
               The authentication hash

    @param playerName
               The name of the player

    @param itemIndex
               The 0-based index of the item being removed

    @return boolean true on success, false on failure

    @throws EAuthException
                If the method call was not correctly authenticated

    @throws EDataException
                If the player was not found

    @throws org.apache.thrift.TException
                If something went wrong with Thrift

    Parameters:
     - authString
     - playerName
     - itemIndex
    """
    self.send_removeInventoryItem(authString, playerName, itemIndex)
    return self.recv_removeInventoryItem()

  def send_removeInventoryItem(self, authString, playerName, itemIndex):
    self._oprot.writeMessageBegin('removeInventoryItem', TMessageType.CALL, self._seqid)
    args = removeInventoryItem_args()
    args.authString = authString
    args.playerName = playerName
    args.itemIndex = itemIndex
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_removeInventoryItem(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = removeInventoryItem_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.aex is not None:
      raise result.aex
    if result.dex is not None:
      raise result.dex
    raise TApplicationException(TApplicationException.MISSING_RESULT, "removeInventoryItem failed: unknown result");

  def removeFromWhitelist(self, authString, name):
    """
    Remove a Player from the server's whitelist. The player can be offline, or
    be a player that has never played on this server before. If the player is not
    already on the whitelist, this method does nothing.

    @param authString
               The authentication hash

    @param name
               The name of the player to remove from the whitelist

    @return boolean true on success, false on failure

    @throws EAuthException
                If the method call was not correctly authenticated

    @throws EDataException
                If the player was not found

    @throws org.apache.thrift.TException
                If something went wrong with Thrift

    Parameters:
     - authString
     - name
    """
    self.send_removeFromWhitelist(authString, name)
    return self.recv_removeFromWhitelist()

  def send_removeFromWhitelist(self, authString, name):
    self._oprot.writeMessageBegin('removeFromWhitelist', TMessageType.CALL, self._seqid)
    args = removeFromWhitelist_args()
    args.authString = authString
    args.name = name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_removeFromWhitelist(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = removeFromWhitelist_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.aex is not None:
      raise result.aex
    if result.dex is not None:
      raise result.dex
    raise TApplicationException(TApplicationException.MISSING_RESULT, "removeFromWhitelist failed: unknown result");

  def replacePlugin(self, authString, pluginName, downloadUrl, md5):
    """
    This method will replace a given plugin's .jar file with a new
    version downloaded from the internet. The old .jar file will be moved
    to a folder inside the SwiftApi Plugin's data folder called
    "oldPlugins/" under the name
    <PluginName>_<Version>-<Timestamp>.jar.old

    @param authString
               The authentication hash

    @param pluginName
               The name of the plugin to replace

    @param downloadUrl
               The URL of the file to be downloaded

    @param md5
               The md5 hash of the file that is being downloaded

    @return boolean true on success false on failure

    @throws EAuthException
                If the method call was not correctly authenticated

    @throws EDataException
                If something went wrong during the file download, or the
                computed hash does not match the provided hash or the
                requested plugin could not be found.

    @throws org.apache.thrift.TException
                If something went wrong with Thrift

    Parameters:
     - authString
     - pluginName
     - downloadUrl
     - md5
    """
    self.send_replacePlugin(authString, pluginName, downloadUrl, md5)
    return self.recv_replacePlugin()

  def send_replacePlugin(self, authString, pluginName, downloadUrl, md5):
    self._oprot.writeMessageBegin('replacePlugin', TMessageType.CALL, self._seqid)
    args = replacePlugin_args()
    args.authString = authString
    args.pluginName = pluginName
    args.downloadUrl = downloadUrl
    args.md5 = md5
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_replacePlugin(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = replacePlugin_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.aex is not None:
      raise result.aex
    if result.dex is not None:
      raise result.dex
    raise TApplicationException(TApplicationException.MISSING_RESULT, "replacePlugin failed: unknown result");

  def runConsoleCommand(self, authString, command):
    """
    Executes a command as if you were to type it directly into the console
    (no need for leading forward-slash "/").

    @param authString
               The authentication hash

    @return boolean true on success false on serious failure

    @throws EAuthException
                If the method call was not correctly authenticated

    @throws org.apache.thrift.TException
                If something went wrong with Thrift

    Parameters:
     - authString
     - command
    """
    self.send_runConsoleCommand(authString, command)

  def send_runConsoleCommand(self, authString, command):
    self._oprot.writeMessageBegin('runConsoleCommand', TMessageType.CALL, self._seqid)
    args = runConsoleCommand_args()
    args.authString = authString
    args.command = command
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()
  def saveWorld(self, authString, worldName):
    """
    Saves the specified world to disk

    @param authString
               The authentication hash

    @param worldName
               The name of the world to save

    @return boolean true on success false on serious failure

    @throws EAuthException
                If the method call was not correctly authenticated

    @throws EDataException
                If the specified world could not be found

    @throws org.apache.thrift.TException
                If something went wrong with Thrift

    Parameters:
     - authString
     - worldName
    """
    self.send_saveWorld(authString, worldName)
    return self.recv_saveWorld()

  def send_saveWorld(self, authString, worldName):
    self._oprot.writeMessageBegin('saveWorld', TMessageType.CALL, self._seqid)
    args = saveWorld_args()
    args.authString = authString
    args.worldName = worldName
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_saveWorld(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = saveWorld_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.aex is not None:
      raise result.aex
    if result.dex is not None:
      raise result.dex
    raise TApplicationException(TApplicationException.MISSING_RESULT, "saveWorld failed: unknown result");

  def setFileContents(self, authString, fileName, fileContents):
    """
    Sets the contents of a file.

    @param authString
               The authentication hash

    @param fileName
               The file to set. The fileName is relative to /plugins. This
    		  method cannot set the contents of any file outside /plugins.

    @throws TException
                If something thrifty went wrong

    @throws EAuthException
                If the method call was not correctly authenticated

    @throws EDataException
                If the file could not be opened or does not exist

    @return bool true on success, else false


    Parameters:
     - authString
     - fileName
     - fileContents
    """
    self.send_setFileContents(authString, fileName, fileContents)
    return self.recv_setFileContents()

  def send_setFileContents(self, authString, fileName, fileContents):
    self._oprot.writeMessageBegin('setFileContents', TMessageType.CALL, self._seqid)
    args = setFileContents_args()
    args.authString = authString
    args.fileName = fileName
    args.fileContents = fileContents
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_setFileContents(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = setFileContents_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.aex is not None:
      raise result.aex
    if result.dex is not None:
      raise result.dex
    raise TApplicationException(TApplicationException.MISSING_RESULT, "setFileContents failed: unknown result");

  def setGameMode(self, authString, name, mode):
    """
    Sets the gamemode of a player

    @param authString
               The authentication hash

    @param name
               The name of the player

    @param mode
               The GameMode to set the player to

    @throws TException
                If something thrifty went wrong

    @throws EAuthException
                If the method call was not correctly authenticated

    @throws EDataException
                If the Player was not found

    @return String the current bukkit version


    Parameters:
     - authString
     - name
     - mode
    """
    self.send_setGameMode(authString, name, mode)
    return self.recv_setGameMode()

  def send_setGameMode(self, authString, name, mode):
    self._oprot.writeMessageBegin('setGameMode', TMessageType.CALL, self._seqid)
    args = setGameMode_args()
    args.authString = authString
    args.name = name
    args.mode = mode
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_setGameMode(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = setGameMode_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.aex is not None:
      raise result.aex
    if result.dex is not None:
      raise result.dex
    raise TApplicationException(TApplicationException.MISSING_RESULT, "setGameMode failed: unknown result");

  def setPvp(self, authString, worldName, isPvp):
    """
    Set's the isPVP property on the specified world

    @param authString
               The authentication hash

    @param worldName
               The name of the world to set the pvp flag for

    @param isPvp
               The value to set the isPVP property to

    @return boolean true on success false on serious failure

    @throws EAuthException
                If the method call was not correctly authenticated

    @throws EDataException
                If the specified world could not be found

    @throws org.apache.thrift.TException
                If something went wrong with Thrift

    Parameters:
     - authString
     - worldName
     - isPvp
    """
    self.send_setPvp(authString, worldName, isPvp)
    return self.recv_setPvp()

  def send_setPvp(self, authString, worldName, isPvp):
    self._oprot.writeMessageBegin('setPvp', TMessageType.CALL, self._seqid)
    args = setPvp_args()
    args.authString = authString
    args.worldName = worldName
    args.isPvp = isPvp
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_setPvp(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = setPvp_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.aex is not None:
      raise result.aex
    if result.dex is not None:
      raise result.dex
    raise TApplicationException(TApplicationException.MISSING_RESULT, "setPvp failed: unknown result");

  def setStorm(self, authString, worldName, hasStorm):
    """
    Set's the hasStorm property on the specified world (i.e. makes it rain)

    @param authString
               The authentication hash

    @param worldName
               The name of the world to set the storm for

    @param hasStorm
               The value to set the storm property to

    @return boolean true on success false on serious failure

    @throws EAuthException
                If the method call was not correctly authenticated

    @throws EDataException
                If the specified world could not be found

    @throws org.apache.thrift.TException
                If something went wrong with Thrift

    Parameters:
     - authString
     - worldName
     - hasStorm
    """
    self.send_setStorm(authString, worldName, hasStorm)
    return self.recv_setStorm()

  def send_setStorm(self, authString, worldName, hasStorm):
    self._oprot.writeMessageBegin('setStorm', TMessageType.CALL, self._seqid)
    args = setStorm_args()
    args.authString = authString
    args.worldName = worldName
    args.hasStorm = hasStorm
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_setStorm(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = setStorm_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.aex is not None:
      raise result.aex
    if result.dex is not None:
      raise result.dex
    raise TApplicationException(TApplicationException.MISSING_RESULT, "setStorm failed: unknown result");

  def setThundering(self, authString, worldName, isThundering):
    """
    Set's the isThundering property on the specified world

    @param authString
               The authentication hash

    @param worldName
               The name of the world to set the storm for

    @param isThundering
               The value to set the isThundering property to

    @return boolean true on success false on serious failure

    @throws EAuthException
                If the method call was not correctly authenticated

    @throws EDataException
                If the specified world could not be found

    @throws org.apache.thrift.TException
                If something went wrong with Thrift

    Parameters:
     - authString
     - worldName
     - isThundering
    """
    self.send_setThundering(authString, worldName, isThundering)
    return self.recv_setThundering()

  def send_setThundering(self, authString, worldName, isThundering):
    self._oprot.writeMessageBegin('setThundering', TMessageType.CALL, self._seqid)
    args = setThundering_args()
    args.authString = authString
    args.worldName = worldName
    args.isThundering = isThundering
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_setThundering(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = setThundering_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.aex is not None:
      raise result.aex
    if result.dex is not None:
      raise result.dex
    raise TApplicationException(TApplicationException.MISSING_RESULT, "setThundering failed: unknown result");

  def setWorldTime(self, authString, worldName, time):
    """
    Sets the time on the specified world or all worlds if a
    blank world name is specified.

    @param authString
               The authentication hash

    @param worldName
               The name of the world to set the time for. If a blank
    		  world name is specified, the time is set for all worlds.

    @param time
               The value to set the world time

    @return boolean true on success false on serious failure

    @throws EAuthException
                If the method call was not correctly authenticated

    @throws EDataException
                If the specified world could not be found

    @throws org.apache.thrift.TException
                If something went wrong with Thrift

    Parameters:
     - authString
     - worldName
     - time
    """
    self.send_setWorldTime(authString, worldName, time)
    return self.recv_setWorldTime()

  def send_setWorldTime(self, authString, worldName, time):
    self._oprot.writeMessageBegin('setWorldTime', TMessageType.CALL, self._seqid)
    args = setWorldTime_args()
    args.authString = authString
    args.worldName = worldName
    args.time = time
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_setWorldTime(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = setWorldTime_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.aex is not None:
      raise result.aex
    if result.dex is not None:
      raise result.dex
    raise TApplicationException(TApplicationException.MISSING_RESULT, "setWorldTime failed: unknown result");

  def unBan(self, authString, name):
    """
    Un ban a specific player

    @param authString
               The authentication hash

    @param name
               The name of the player to unban

    @return boolean true on success false on failure

    @throws EAuthException
                If the method call was not correctly authenticated

    @throws EDataException
                If the player was not found

    @throws org.apache.thrift.TException
                If something went wrong with Thrift

    Parameters:
     - authString
     - name
    """
    self.send_unBan(authString, name)
    return self.recv_unBan()

  def send_unBan(self, authString, name):
    self._oprot.writeMessageBegin('unBan', TMessageType.CALL, self._seqid)
    args = unBan_args()
    args.authString = authString
    args.name = name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_unBan(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = unBan_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.aex is not None:
      raise result.aex
    if result.dex is not None:
      raise result.dex
    raise TApplicationException(TApplicationException.MISSING_RESULT, "unBan failed: unknown result");

  def unBanIp(self, authString, ip):
    """
    Un ban a specific IP from connecting to this server

    @param authString
               The authentication hash

    @param ip
               The IP to unban

    @return boolean true on success false on failure

    @throws EAuthException
                If the method call was not correctly authenticated

    @throws org.apache.thrift.TException
                If something went wrong with Thrift

    Parameters:
     - authString
     - ip
    """
    self.send_unBanIp(authString, ip)
    return self.recv_unBanIp()

  def send_unBanIp(self, authString, ip):
    self._oprot.writeMessageBegin('unBanIp', TMessageType.CALL, self._seqid)
    args = unBanIp_args()
    args.authString = authString
    args.ip = ip
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_unBanIp(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = unBanIp_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.aex is not None:
      raise result.aex
    if result.dex is not None:
      raise result.dex
    raise TApplicationException(TApplicationException.MISSING_RESULT, "unBanIp failed: unknown result");

  def updateInventoryItem(self, authString, playerName, item, itemIndex):
    """
    Replaces an item in the player's inventory with the supplied one

    @since 1.5

    @param authString
               The authentication hash

    @param playerName
               The name of the player

    @param item
               The item that will replace the item specified by itemIndex, in the form of an ItemStack

    @param itemIndex
               The 0-based index of which item to replace in the inventory

    @return boolean true on success, false on failure

    @throws EAuthException
                If the method call was not correctly authenticated

    @throws EDataException
                If the player was not found

    @throws org.apache.thrift.TException
                If something went wrong with Thrift

    Parameters:
     - authString
     - playerName
     - item
     - itemIndex
    """
    self.send_updateInventoryItem(authString, playerName, item, itemIndex)
    return self.recv_updateInventoryItem()

  def send_updateInventoryItem(self, authString, playerName, item, itemIndex):
    self._oprot.writeMessageBegin('updateInventoryItem', TMessageType.CALL, self._seqid)
    args = updateInventoryItem_args()
    args.authString = authString
    args.playerName = playerName
    args.item = item
    args.itemIndex = itemIndex
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_updateInventoryItem(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = updateInventoryItem_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.aex is not None:
      raise result.aex
    if result.dex is not None:
      raise result.dex
    raise TApplicationException(TApplicationException.MISSING_RESULT, "updateInventoryItem failed: unknown result");


class Processor(Iface, TProcessor):
  def __init__(self, handler):
    self._handler = handler
    self._processMap = {}
    self._processMap["addItemToInventory"] = Processor.process_addItemToInventory
    self._processMap["addToWhitelist"] = Processor.process_addToWhitelist
    self._processMap["announce"] = Processor.process_announce
    self._processMap["ban"] = Processor.process_ban
    self._processMap["banIp"] = Processor.process_banIp
    self._processMap["deOp"] = Processor.process_deOp
    self._processMap["getBannedIps"] = Processor.process_getBannedIps
    self._processMap["getBannedPlayers"] = Processor.process_getBannedPlayers
    self._processMap["getBukkitVersion"] = Processor.process_getBukkitVersion
    self._processMap["getConsoleMessages"] = Processor.process_getConsoleMessages
    self._processMap["getFileContents"] = Processor.process_getFileContents
    self._processMap["getOfflinePlayer"] = Processor.process_getOfflinePlayer
    self._processMap["getOfflinePlayers"] = Processor.process_getOfflinePlayers
    self._processMap["getOps"] = Processor.process_getOps
    self._processMap["getPlayer"] = Processor.process_getPlayer
    self._processMap["getPlayers"] = Processor.process_getPlayers
    self._processMap["getPlugin"] = Processor.process_getPlugin
    self._processMap["getPlugins"] = Processor.process_getPlugins
    self._processMap["getServer"] = Processor.process_getServer
    self._processMap["getServerVersion"] = Processor.process_getServerVersion
    self._processMap["getWhitelist"] = Processor.process_getWhitelist
    self._processMap["getWorld"] = Processor.process_getWorld
    self._processMap["getWorlds"] = Processor.process_getWorlds
    self._processMap["installPlugin"] = Processor.process_installPlugin
    self._processMap["kick"] = Processor.process_kick
    self._processMap["op"] = Processor.process_op
    self._processMap["ping"] = Processor.process_ping
    self._processMap["reloadServer"] = Processor.process_reloadServer
    self._processMap["removeInventoryItem"] = Processor.process_removeInventoryItem
    self._processMap["removeFromWhitelist"] = Processor.process_removeFromWhitelist
    self._processMap["replacePlugin"] = Processor.process_replacePlugin
    self._processMap["runConsoleCommand"] = Processor.process_runConsoleCommand
    self._processMap["saveWorld"] = Processor.process_saveWorld
    self._processMap["setFileContents"] = Processor.process_setFileContents
    self._processMap["setGameMode"] = Processor.process_setGameMode
    self._processMap["setPvp"] = Processor.process_setPvp
    self._processMap["setStorm"] = Processor.process_setStorm
    self._processMap["setThundering"] = Processor.process_setThundering
    self._processMap["setWorldTime"] = Processor.process_setWorldTime
    self._processMap["unBan"] = Processor.process_unBan
    self._processMap["unBanIp"] = Processor.process_unBanIp
    self._processMap["updateInventoryItem"] = Processor.process_updateInventoryItem

  def process(self, iprot, oprot):
    (name, type, seqid) = iprot.readMessageBegin()
    if name not in self._processMap:
      iprot.skip(TType.STRUCT)
      iprot.readMessageEnd()
      x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
      oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
      x.write(oprot)
      oprot.writeMessageEnd()
      oprot.trans.flush()
      return
    else:
      self._processMap[name](self, seqid, iprot, oprot)
    return True

  def process_addItemToInventory(self, seqid, iprot, oprot):
    args = addItemToInventory_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = addItemToInventory_result()
    try:
      result.success = self._handler.addItemToInventory(args.authString, args.playerName, args.item)
    except EAuthException, aex:
      result.aex = aex
    except EDataException, dex:
      result.dex = dex
    oprot.writeMessageBegin("addItemToInventory", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_addToWhitelist(self, seqid, iprot, oprot):
    args = addToWhitelist_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = addToWhitelist_result()
    try:
      result.success = self._handler.addToWhitelist(args.authString, args.name)
    except EAuthException, aex:
      result.aex = aex
    except EDataException, dex:
      result.dex = dex
    oprot.writeMessageBegin("addToWhitelist", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_announce(self, seqid, iprot, oprot):
    args = announce_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = announce_result()
    try:
      result.success = self._handler.announce(args.authString, args.message)
    except EAuthException, aex:
      result.aex = aex
    oprot.writeMessageBegin("announce", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_ban(self, seqid, iprot, oprot):
    args = ban_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = ban_result()
    try:
      result.success = self._handler.ban(args.authString, args.name)
    except EAuthException, aex:
      result.aex = aex
    except EDataException, dex:
      result.dex = dex
    oprot.writeMessageBegin("ban", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_banIp(self, seqid, iprot, oprot):
    args = banIp_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = banIp_result()
    try:
      result.success = self._handler.banIp(args.authString, args.ip)
    except EAuthException, aex:
      result.aex = aex
    oprot.writeMessageBegin("banIp", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_deOp(self, seqid, iprot, oprot):
    args = deOp_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = deOp_result()
    try:
      result.success = self._handler.deOp(args.authString, args.name, args.notifyPlayer)
    except EAuthException, aex:
      result.aex = aex
    except EDataException, dex:
      result.dex = dex
    oprot.writeMessageBegin("deOp", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getBannedIps(self, seqid, iprot, oprot):
    args = getBannedIps_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getBannedIps_result()
    try:
      result.success = self._handler.getBannedIps(args.authString)
    except EAuthException, aex:
      result.aex = aex
    oprot.writeMessageBegin("getBannedIps", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getBannedPlayers(self, seqid, iprot, oprot):
    args = getBannedPlayers_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getBannedPlayers_result()
    try:
      result.success = self._handler.getBannedPlayers(args.authString)
    except EAuthException, aex:
      result.aex = aex
    oprot.writeMessageBegin("getBannedPlayers", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getBukkitVersion(self, seqid, iprot, oprot):
    args = getBukkitVersion_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getBukkitVersion_result()
    try:
      result.success = self._handler.getBukkitVersion(args.authString)
    except EAuthException, aex:
      result.aex = aex
    oprot.writeMessageBegin("getBukkitVersion", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getConsoleMessages(self, seqid, iprot, oprot):
    args = getConsoleMessages_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getConsoleMessages_result()
    try:
      result.success = self._handler.getConsoleMessages(args.authString, args.since)
    except EAuthException, aex:
      result.aex = aex
    oprot.writeMessageBegin("getConsoleMessages", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getFileContents(self, seqid, iprot, oprot):
    args = getFileContents_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getFileContents_result()
    try:
      result.success = self._handler.getFileContents(args.authString, args.fileName)
    except EAuthException, aex:
      result.aex = aex
    except EDataException, dex:
      result.dex = dex
    oprot.writeMessageBegin("getFileContents", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getOfflinePlayer(self, seqid, iprot, oprot):
    args = getOfflinePlayer_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getOfflinePlayer_result()
    try:
      result.success = self._handler.getOfflinePlayer(args.authString, args.name)
    except EAuthException, aex:
      result.aex = aex
    except EDataException, dex:
      result.dex = dex
    oprot.writeMessageBegin("getOfflinePlayer", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getOfflinePlayers(self, seqid, iprot, oprot):
    args = getOfflinePlayers_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getOfflinePlayers_result()
    try:
      result.success = self._handler.getOfflinePlayers(args.authString)
    except EAuthException, aex:
      result.aex = aex
    oprot.writeMessageBegin("getOfflinePlayers", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getOps(self, seqid, iprot, oprot):
    args = getOps_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getOps_result()
    try:
      result.success = self._handler.getOps(args.authString)
    except EAuthException, aex:
      result.aex = aex
    oprot.writeMessageBegin("getOps", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getPlayer(self, seqid, iprot, oprot):
    args = getPlayer_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getPlayer_result()
    try:
      result.success = self._handler.getPlayer(args.authString, args.name)
    except EAuthException, aex:
      result.aex = aex
    except EDataException, dex:
      result.dex = dex
    oprot.writeMessageBegin("getPlayer", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getPlayers(self, seqid, iprot, oprot):
    args = getPlayers_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getPlayers_result()
    try:
      result.success = self._handler.getPlayers(args.authString)
    except EAuthException, aex:
      result.aex = aex
    oprot.writeMessageBegin("getPlayers", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getPlugin(self, seqid, iprot, oprot):
    args = getPlugin_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getPlugin_result()
    try:
      result.success = self._handler.getPlugin(args.authString, args.name)
    except EAuthException, aex:
      result.aex = aex
    except EDataException, dex:
      result.dex = dex
    oprot.writeMessageBegin("getPlugin", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getPlugins(self, seqid, iprot, oprot):
    args = getPlugins_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getPlugins_result()
    try:
      result.success = self._handler.getPlugins(args.authString)
    except EAuthException, aex:
      result.aex = aex
    oprot.writeMessageBegin("getPlugins", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getServer(self, seqid, iprot, oprot):
    args = getServer_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getServer_result()
    try:
      result.success = self._handler.getServer(args.authString)
    except EAuthException, aex:
      result.aex = aex
    oprot.writeMessageBegin("getServer", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getServerVersion(self, seqid, iprot, oprot):
    args = getServerVersion_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getServerVersion_result()
    try:
      result.success = self._handler.getServerVersion(args.authString)
    except EAuthException, aex:
      result.aex = aex
    oprot.writeMessageBegin("getServerVersion", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getWhitelist(self, seqid, iprot, oprot):
    args = getWhitelist_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getWhitelist_result()
    try:
      result.success = self._handler.getWhitelist(args.authString)
    except EAuthException, aex:
      result.aex = aex
    oprot.writeMessageBegin("getWhitelist", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getWorld(self, seqid, iprot, oprot):
    args = getWorld_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getWorld_result()
    try:
      result.success = self._handler.getWorld(args.authString, args.worldName)
    except EAuthException, aex:
      result.aex = aex
    except EDataException, dex:
      result.dex = dex
    oprot.writeMessageBegin("getWorld", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getWorlds(self, seqid, iprot, oprot):
    args = getWorlds_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getWorlds_result()
    try:
      result.success = self._handler.getWorlds(args.authString)
    except EAuthException, aex:
      result.aex = aex
    oprot.writeMessageBegin("getWorlds", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_installPlugin(self, seqid, iprot, oprot):
    args = installPlugin_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = installPlugin_result()
    try:
      result.success = self._handler.installPlugin(args.authString, args.downloadUrl, args.md5)
    except EAuthException, aex:
      result.aex = aex
    except EDataException, dex:
      result.dex = dex
    oprot.writeMessageBegin("installPlugin", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_kick(self, seqid, iprot, oprot):
    args = kick_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = kick_result()
    try:
      result.success = self._handler.kick(args.authString, args.name, args.message)
    except EAuthException, aex:
      result.aex = aex
    except EDataException, dex:
      result.dex = dex
    oprot.writeMessageBegin("kick", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_op(self, seqid, iprot, oprot):
    args = op_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = op_result()
    try:
      result.success = self._handler.op(args.authString, args.name, args.notifyPlayer)
    except EAuthException, aex:
      result.aex = aex
    except EDataException, dex:
      result.dex = dex
    oprot.writeMessageBegin("op", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_ping(self, seqid, iprot, oprot):
    args = ping_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = ping_result()
    try:
      result.success = self._handler.ping(args.authString)
    except EAuthException, aex:
      result.aex = aex
    oprot.writeMessageBegin("ping", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_reloadServer(self, seqid, iprot, oprot):
    args = reloadServer_args()
    args.read(iprot)
    iprot.readMessageEnd()
    self._handler.reloadServer(args.authString)
    return

  def process_removeInventoryItem(self, seqid, iprot, oprot):
    args = removeInventoryItem_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = removeInventoryItem_result()
    try:
      result.success = self._handler.removeInventoryItem(args.authString, args.playerName, args.itemIndex)
    except EAuthException, aex:
      result.aex = aex
    except EDataException, dex:
      result.dex = dex
    oprot.writeMessageBegin("removeInventoryItem", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_removeFromWhitelist(self, seqid, iprot, oprot):
    args = removeFromWhitelist_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = removeFromWhitelist_result()
    try:
      result.success = self._handler.removeFromWhitelist(args.authString, args.name)
    except EAuthException, aex:
      result.aex = aex
    except EDataException, dex:
      result.dex = dex
    oprot.writeMessageBegin("removeFromWhitelist", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_replacePlugin(self, seqid, iprot, oprot):
    args = replacePlugin_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = replacePlugin_result()
    try:
      result.success = self._handler.replacePlugin(args.authString, args.pluginName, args.downloadUrl, args.md5)
    except EAuthException, aex:
      result.aex = aex
    except EDataException, dex:
      result.dex = dex
    oprot.writeMessageBegin("replacePlugin", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_runConsoleCommand(self, seqid, iprot, oprot):
    args = runConsoleCommand_args()
    args.read(iprot)
    iprot.readMessageEnd()
    self._handler.runConsoleCommand(args.authString, args.command)
    return

  def process_saveWorld(self, seqid, iprot, oprot):
    args = saveWorld_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = saveWorld_result()
    try:
      result.success = self._handler.saveWorld(args.authString, args.worldName)
    except EAuthException, aex:
      result.aex = aex
    except EDataException, dex:
      result.dex = dex
    oprot.writeMessageBegin("saveWorld", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_setFileContents(self, seqid, iprot, oprot):
    args = setFileContents_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = setFileContents_result()
    try:
      result.success = self._handler.setFileContents(args.authString, args.fileName, args.fileContents)
    except EAuthException, aex:
      result.aex = aex
    except EDataException, dex:
      result.dex = dex
    oprot.writeMessageBegin("setFileContents", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_setGameMode(self, seqid, iprot, oprot):
    args = setGameMode_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = setGameMode_result()
    try:
      result.success = self._handler.setGameMode(args.authString, args.name, args.mode)
    except EAuthException, aex:
      result.aex = aex
    except EDataException, dex:
      result.dex = dex
    oprot.writeMessageBegin("setGameMode", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_setPvp(self, seqid, iprot, oprot):
    args = setPvp_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = setPvp_result()
    try:
      result.success = self._handler.setPvp(args.authString, args.worldName, args.isPvp)
    except EAuthException, aex:
      result.aex = aex
    except EDataException, dex:
      result.dex = dex
    oprot.writeMessageBegin("setPvp", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_setStorm(self, seqid, iprot, oprot):
    args = setStorm_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = setStorm_result()
    try:
      result.success = self._handler.setStorm(args.authString, args.worldName, args.hasStorm)
    except EAuthException, aex:
      result.aex = aex
    except EDataException, dex:
      result.dex = dex
    oprot.writeMessageBegin("setStorm", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_setThundering(self, seqid, iprot, oprot):
    args = setThundering_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = setThundering_result()
    try:
      result.success = self._handler.setThundering(args.authString, args.worldName, args.isThundering)
    except EAuthException, aex:
      result.aex = aex
    except EDataException, dex:
      result.dex = dex
    oprot.writeMessageBegin("setThundering", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_setWorldTime(self, seqid, iprot, oprot):
    args = setWorldTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = setWorldTime_result()
    try:
      result.success = self._handler.setWorldTime(args.authString, args.worldName, args.time)
    except EAuthException, aex:
      result.aex = aex
    except EDataException, dex:
      result.dex = dex
    oprot.writeMessageBegin("setWorldTime", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_unBan(self, seqid, iprot, oprot):
    args = unBan_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = unBan_result()
    try:
      result.success = self._handler.unBan(args.authString, args.name)
    except EAuthException, aex:
      result.aex = aex
    except EDataException, dex:
      result.dex = dex
    oprot.writeMessageBegin("unBan", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_unBanIp(self, seqid, iprot, oprot):
    args = unBanIp_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = unBanIp_result()
    try:
      result.success = self._handler.unBanIp(args.authString, args.ip)
    except EAuthException, aex:
      result.aex = aex
    except EDataException, dex:
      result.dex = dex
    oprot.writeMessageBegin("unBanIp", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_updateInventoryItem(self, seqid, iprot, oprot):
    args = updateInventoryItem_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = updateInventoryItem_result()
    try:
      result.success = self._handler.updateInventoryItem(args.authString, args.playerName, args.item, args.itemIndex)
    except EAuthException, aex:
      result.aex = aex
    except EDataException, dex:
      result.dex = dex
    oprot.writeMessageBegin("updateInventoryItem", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()


# HELPER FUNCTIONS AND STRUCTURES

class addItemToInventory_args:
  """
  Attributes:
   - authString
   - playerName
   - item
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authString', None, None, ), # 1
    (2, TType.STRING, 'playerName', None, None, ), # 2
    (3, TType.STRUCT, 'item', (ItemStack, ItemStack.thrift_spec), None, ), # 3
  )

  def __init__(self, authString=None, playerName=None, item=None,):
    self.authString = authString
    self.playerName = playerName
    self.item = item

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authString = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.playerName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.item = ItemStack()
          self.item.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('addItemToInventory_args')
    if self.authString is not None:
      oprot.writeFieldBegin('authString', TType.STRING, 1)
      oprot.writeString(self.authString)
      oprot.writeFieldEnd()
    if self.playerName is not None:
      oprot.writeFieldBegin('playerName', TType.STRING, 2)
      oprot.writeString(self.playerName)
      oprot.writeFieldEnd()
    if self.item is not None:
      oprot.writeFieldBegin('item', TType.STRUCT, 3)
      self.item.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class addItemToInventory_result:
  """
  Attributes:
   - success
   - aex
   - dex
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'aex', (EAuthException, EAuthException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'dex', (EDataException, EDataException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, aex=None, dex=None,):
    self.success = success
    self.aex = aex
    self.dex = dex

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.aex = EAuthException()
          self.aex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dex = EDataException()
          self.dex.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('addItemToInventory_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.aex is not None:
      oprot.writeFieldBegin('aex', TType.STRUCT, 1)
      self.aex.write(oprot)
      oprot.writeFieldEnd()
    if self.dex is not None:
      oprot.writeFieldBegin('dex', TType.STRUCT, 2)
      self.dex.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class addToWhitelist_args:
  """
  Attributes:
   - authString
   - name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authString', None, None, ), # 1
    (2, TType.STRING, 'name', None, None, ), # 2
  )

  def __init__(self, authString=None, name=None,):
    self.authString = authString
    self.name = name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authString = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.name = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('addToWhitelist_args')
    if self.authString is not None:
      oprot.writeFieldBegin('authString', TType.STRING, 1)
      oprot.writeString(self.authString)
      oprot.writeFieldEnd()
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 2)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class addToWhitelist_result:
  """
  Attributes:
   - success
   - aex
   - dex
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'aex', (EAuthException, EAuthException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'dex', (EDataException, EDataException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, aex=None, dex=None,):
    self.success = success
    self.aex = aex
    self.dex = dex

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.aex = EAuthException()
          self.aex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dex = EDataException()
          self.dex.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('addToWhitelist_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.aex is not None:
      oprot.writeFieldBegin('aex', TType.STRUCT, 1)
      self.aex.write(oprot)
      oprot.writeFieldEnd()
    if self.dex is not None:
      oprot.writeFieldBegin('dex', TType.STRUCT, 2)
      self.dex.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class announce_args:
  """
  Attributes:
   - authString
   - message
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authString', None, None, ), # 1
    (2, TType.STRING, 'message', None, None, ), # 2
  )

  def __init__(self, authString=None, message=None,):
    self.authString = authString
    self.message = message

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authString = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.message = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('announce_args')
    if self.authString is not None:
      oprot.writeFieldBegin('authString', TType.STRING, 1)
      oprot.writeString(self.authString)
      oprot.writeFieldEnd()
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 2)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class announce_result:
  """
  Attributes:
   - success
   - aex
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'aex', (EAuthException, EAuthException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, aex=None,):
    self.success = success
    self.aex = aex

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.aex = EAuthException()
          self.aex.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('announce_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.aex is not None:
      oprot.writeFieldBegin('aex', TType.STRUCT, 1)
      self.aex.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ban_args:
  """
  Attributes:
   - authString
   - name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authString', None, None, ), # 1
    (2, TType.STRING, 'name', None, None, ), # 2
  )

  def __init__(self, authString=None, name=None,):
    self.authString = authString
    self.name = name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authString = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.name = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ban_args')
    if self.authString is not None:
      oprot.writeFieldBegin('authString', TType.STRING, 1)
      oprot.writeString(self.authString)
      oprot.writeFieldEnd()
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 2)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ban_result:
  """
  Attributes:
   - success
   - aex
   - dex
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'aex', (EAuthException, EAuthException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'dex', (EDataException, EDataException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, aex=None, dex=None,):
    self.success = success
    self.aex = aex
    self.dex = dex

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.aex = EAuthException()
          self.aex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dex = EDataException()
          self.dex.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ban_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.aex is not None:
      oprot.writeFieldBegin('aex', TType.STRUCT, 1)
      self.aex.write(oprot)
      oprot.writeFieldEnd()
    if self.dex is not None:
      oprot.writeFieldBegin('dex', TType.STRUCT, 2)
      self.dex.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class banIp_args:
  """
  Attributes:
   - authString
   - ip
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authString', None, None, ), # 1
    (2, TType.STRING, 'ip', None, None, ), # 2
  )

  def __init__(self, authString=None, ip=None,):
    self.authString = authString
    self.ip = ip

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authString = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ip = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('banIp_args')
    if self.authString is not None:
      oprot.writeFieldBegin('authString', TType.STRING, 1)
      oprot.writeString(self.authString)
      oprot.writeFieldEnd()
    if self.ip is not None:
      oprot.writeFieldBegin('ip', TType.STRING, 2)
      oprot.writeString(self.ip)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class banIp_result:
  """
  Attributes:
   - success
   - aex
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'aex', (EAuthException, EAuthException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, aex=None,):
    self.success = success
    self.aex = aex

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.aex = EAuthException()
          self.aex.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('banIp_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.aex is not None:
      oprot.writeFieldBegin('aex', TType.STRUCT, 1)
      self.aex.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class deOp_args:
  """
  Attributes:
   - authString
   - name
   - notifyPlayer
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authString', None, None, ), # 1
    (2, TType.STRING, 'name', None, None, ), # 2
    (3, TType.BOOL, 'notifyPlayer', None, None, ), # 3
  )

  def __init__(self, authString=None, name=None, notifyPlayer=None,):
    self.authString = authString
    self.name = name
    self.notifyPlayer = notifyPlayer

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authString = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.notifyPlayer = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('deOp_args')
    if self.authString is not None:
      oprot.writeFieldBegin('authString', TType.STRING, 1)
      oprot.writeString(self.authString)
      oprot.writeFieldEnd()
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 2)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.notifyPlayer is not None:
      oprot.writeFieldBegin('notifyPlayer', TType.BOOL, 3)
      oprot.writeBool(self.notifyPlayer)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class deOp_result:
  """
  Attributes:
   - success
   - aex
   - dex
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'aex', (EAuthException, EAuthException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'dex', (EDataException, EDataException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, aex=None, dex=None,):
    self.success = success
    self.aex = aex
    self.dex = dex

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.aex = EAuthException()
          self.aex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dex = EDataException()
          self.dex.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('deOp_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.aex is not None:
      oprot.writeFieldBegin('aex', TType.STRUCT, 1)
      self.aex.write(oprot)
      oprot.writeFieldEnd()
    if self.dex is not None:
      oprot.writeFieldBegin('dex', TType.STRUCT, 2)
      self.dex.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getBannedIps_args:
  """
  Attributes:
   - authString
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authString', None, None, ), # 1
  )

  def __init__(self, authString=None,):
    self.authString = authString

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authString = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getBannedIps_args')
    if self.authString is not None:
      oprot.writeFieldBegin('authString', TType.STRING, 1)
      oprot.writeString(self.authString)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getBannedIps_result:
  """
  Attributes:
   - success
   - aex
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'aex', (EAuthException, EAuthException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, aex=None,):
    self.success = success
    self.aex = aex

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype82, _size79) = iprot.readListBegin()
          for _i83 in xrange(_size79):
            _elem84 = iprot.readString();
            self.success.append(_elem84)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.aex = EAuthException()
          self.aex.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getBannedIps_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRING, len(self.success))
      for iter85 in self.success:
        oprot.writeString(iter85)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.aex is not None:
      oprot.writeFieldBegin('aex', TType.STRUCT, 1)
      self.aex.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getBannedPlayers_args:
  """
  Attributes:
   - authString
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authString', None, None, ), # 1
  )

  def __init__(self, authString=None,):
    self.authString = authString

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authString = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getBannedPlayers_args')
    if self.authString is not None:
      oprot.writeFieldBegin('authString', TType.STRING, 1)
      oprot.writeString(self.authString)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getBannedPlayers_result:
  """
  Attributes:
   - success
   - aex
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(OfflinePlayer, OfflinePlayer.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'aex', (EAuthException, EAuthException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, aex=None,):
    self.success = success
    self.aex = aex

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype89, _size86) = iprot.readListBegin()
          for _i90 in xrange(_size86):
            _elem91 = OfflinePlayer()
            _elem91.read(iprot)
            self.success.append(_elem91)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.aex = EAuthException()
          self.aex.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getBannedPlayers_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter92 in self.success:
        iter92.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.aex is not None:
      oprot.writeFieldBegin('aex', TType.STRUCT, 1)
      self.aex.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getBukkitVersion_args:
  """
  Attributes:
   - authString
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authString', None, None, ), # 1
  )

  def __init__(self, authString=None,):
    self.authString = authString

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authString = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getBukkitVersion_args')
    if self.authString is not None:
      oprot.writeFieldBegin('authString', TType.STRING, 1)
      oprot.writeString(self.authString)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getBukkitVersion_result:
  """
  Attributes:
   - success
   - aex
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'aex', (EAuthException, EAuthException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, aex=None,):
    self.success = success
    self.aex = aex

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.aex = EAuthException()
          self.aex.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getBukkitVersion_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.aex is not None:
      oprot.writeFieldBegin('aex', TType.STRUCT, 1)
      self.aex.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getConsoleMessages_args:
  """
  Attributes:
   - authString
   - since
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authString', None, None, ), # 1
    (2, TType.I64, 'since', None, None, ), # 2
  )

  def __init__(self, authString=None, since=None,):
    self.authString = authString
    self.since = since

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authString = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.since = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getConsoleMessages_args')
    if self.authString is not None:
      oprot.writeFieldBegin('authString', TType.STRING, 1)
      oprot.writeString(self.authString)
      oprot.writeFieldEnd()
    if self.since is not None:
      oprot.writeFieldBegin('since', TType.I64, 2)
      oprot.writeI64(self.since)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getConsoleMessages_result:
  """
  Attributes:
   - success
   - aex
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(ConsoleLine, ConsoleLine.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'aex', (EAuthException, EAuthException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, aex=None,):
    self.success = success
    self.aex = aex

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype96, _size93) = iprot.readListBegin()
          for _i97 in xrange(_size93):
            _elem98 = ConsoleLine()
            _elem98.read(iprot)
            self.success.append(_elem98)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.aex = EAuthException()
          self.aex.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getConsoleMessages_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter99 in self.success:
        iter99.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.aex is not None:
      oprot.writeFieldBegin('aex', TType.STRUCT, 1)
      self.aex.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getFileContents_args:
  """
  Attributes:
   - authString
   - fileName
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authString', None, None, ), # 1
    (2, TType.STRING, 'fileName', None, None, ), # 2
  )

  def __init__(self, authString=None, fileName=None,):
    self.authString = authString
    self.fileName = fileName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authString = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.fileName = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getFileContents_args')
    if self.authString is not None:
      oprot.writeFieldBegin('authString', TType.STRING, 1)
      oprot.writeString(self.authString)
      oprot.writeFieldEnd()
    if self.fileName is not None:
      oprot.writeFieldBegin('fileName', TType.STRING, 2)
      oprot.writeString(self.fileName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getFileContents_result:
  """
  Attributes:
   - success
   - aex
   - dex
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'aex', (EAuthException, EAuthException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'dex', (EDataException, EDataException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, aex=None, dex=None,):
    self.success = success
    self.aex = aex
    self.dex = dex

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.aex = EAuthException()
          self.aex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dex = EDataException()
          self.dex.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getFileContents_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.aex is not None:
      oprot.writeFieldBegin('aex', TType.STRUCT, 1)
      self.aex.write(oprot)
      oprot.writeFieldEnd()
    if self.dex is not None:
      oprot.writeFieldBegin('dex', TType.STRUCT, 2)
      self.dex.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getOfflinePlayer_args:
  """
  Attributes:
   - authString
   - name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authString', None, None, ), # 1
    (2, TType.STRING, 'name', None, None, ), # 2
  )

  def __init__(self, authString=None, name=None,):
    self.authString = authString
    self.name = name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authString = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.name = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getOfflinePlayer_args')
    if self.authString is not None:
      oprot.writeFieldBegin('authString', TType.STRING, 1)
      oprot.writeString(self.authString)
      oprot.writeFieldEnd()
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 2)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getOfflinePlayer_result:
  """
  Attributes:
   - success
   - aex
   - dex
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (OfflinePlayer, OfflinePlayer.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'aex', (EAuthException, EAuthException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'dex', (EDataException, EDataException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, aex=None, dex=None,):
    self.success = success
    self.aex = aex
    self.dex = dex

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = OfflinePlayer()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.aex = EAuthException()
          self.aex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dex = EDataException()
          self.dex.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getOfflinePlayer_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.aex is not None:
      oprot.writeFieldBegin('aex', TType.STRUCT, 1)
      self.aex.write(oprot)
      oprot.writeFieldEnd()
    if self.dex is not None:
      oprot.writeFieldBegin('dex', TType.STRUCT, 2)
      self.dex.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getOfflinePlayers_args:
  """
  Attributes:
   - authString
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authString', None, None, ), # 1
  )

  def __init__(self, authString=None,):
    self.authString = authString

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authString = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getOfflinePlayers_args')
    if self.authString is not None:
      oprot.writeFieldBegin('authString', TType.STRING, 1)
      oprot.writeString(self.authString)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getOfflinePlayers_result:
  """
  Attributes:
   - success
   - aex
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(OfflinePlayer, OfflinePlayer.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'aex', (EAuthException, EAuthException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, aex=None,):
    self.success = success
    self.aex = aex

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype103, _size100) = iprot.readListBegin()
          for _i104 in xrange(_size100):
            _elem105 = OfflinePlayer()
            _elem105.read(iprot)
            self.success.append(_elem105)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.aex = EAuthException()
          self.aex.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getOfflinePlayers_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter106 in self.success:
        iter106.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.aex is not None:
      oprot.writeFieldBegin('aex', TType.STRUCT, 1)
      self.aex.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getOps_args:
  """
  Attributes:
   - authString
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authString', None, None, ), # 1
  )

  def __init__(self, authString=None,):
    self.authString = authString

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authString = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getOps_args')
    if self.authString is not None:
      oprot.writeFieldBegin('authString', TType.STRING, 1)
      oprot.writeString(self.authString)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getOps_result:
  """
  Attributes:
   - success
   - aex
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(OfflinePlayer, OfflinePlayer.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'aex', (EAuthException, EAuthException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, aex=None,):
    self.success = success
    self.aex = aex

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype110, _size107) = iprot.readListBegin()
          for _i111 in xrange(_size107):
            _elem112 = OfflinePlayer()
            _elem112.read(iprot)
            self.success.append(_elem112)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.aex = EAuthException()
          self.aex.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getOps_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter113 in self.success:
        iter113.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.aex is not None:
      oprot.writeFieldBegin('aex', TType.STRUCT, 1)
      self.aex.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getPlayer_args:
  """
  Attributes:
   - authString
   - name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authString', None, None, ), # 1
    (2, TType.STRING, 'name', None, None, ), # 2
  )

  def __init__(self, authString=None, name=None,):
    self.authString = authString
    self.name = name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authString = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.name = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getPlayer_args')
    if self.authString is not None:
      oprot.writeFieldBegin('authString', TType.STRING, 1)
      oprot.writeString(self.authString)
      oprot.writeFieldEnd()
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 2)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getPlayer_result:
  """
  Attributes:
   - success
   - aex
   - dex
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Player, Player.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'aex', (EAuthException, EAuthException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'dex', (EDataException, EDataException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, aex=None, dex=None,):
    self.success = success
    self.aex = aex
    self.dex = dex

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Player()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.aex = EAuthException()
          self.aex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dex = EDataException()
          self.dex.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getPlayer_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.aex is not None:
      oprot.writeFieldBegin('aex', TType.STRUCT, 1)
      self.aex.write(oprot)
      oprot.writeFieldEnd()
    if self.dex is not None:
      oprot.writeFieldBegin('dex', TType.STRUCT, 2)
      self.dex.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getPlayers_args:
  """
  Attributes:
   - authString
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authString', None, None, ), # 1
  )

  def __init__(self, authString=None,):
    self.authString = authString

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authString = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getPlayers_args')
    if self.authString is not None:
      oprot.writeFieldBegin('authString', TType.STRING, 1)
      oprot.writeString(self.authString)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getPlayers_result:
  """
  Attributes:
   - success
   - aex
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(Player, Player.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'aex', (EAuthException, EAuthException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, aex=None,):
    self.success = success
    self.aex = aex

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype117, _size114) = iprot.readListBegin()
          for _i118 in xrange(_size114):
            _elem119 = Player()
            _elem119.read(iprot)
            self.success.append(_elem119)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.aex = EAuthException()
          self.aex.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getPlayers_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter120 in self.success:
        iter120.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.aex is not None:
      oprot.writeFieldBegin('aex', TType.STRUCT, 1)
      self.aex.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getPlugin_args:
  """
  Attributes:
   - authString
   - name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authString', None, None, ), # 1
    (2, TType.STRING, 'name', None, None, ), # 2
  )

  def __init__(self, authString=None, name=None,):
    self.authString = authString
    self.name = name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authString = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.name = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getPlugin_args')
    if self.authString is not None:
      oprot.writeFieldBegin('authString', TType.STRING, 1)
      oprot.writeString(self.authString)
      oprot.writeFieldEnd()
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 2)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getPlugin_result:
  """
  Attributes:
   - success
   - aex
   - dex
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Plugin, Plugin.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'aex', (EAuthException, EAuthException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'dex', (EDataException, EDataException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, aex=None, dex=None,):
    self.success = success
    self.aex = aex
    self.dex = dex

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Plugin()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.aex = EAuthException()
          self.aex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dex = EDataException()
          self.dex.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getPlugin_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.aex is not None:
      oprot.writeFieldBegin('aex', TType.STRUCT, 1)
      self.aex.write(oprot)
      oprot.writeFieldEnd()
    if self.dex is not None:
      oprot.writeFieldBegin('dex', TType.STRUCT, 2)
      self.dex.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getPlugins_args:
  """
  Attributes:
   - authString
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authString', None, None, ), # 1
  )

  def __init__(self, authString=None,):
    self.authString = authString

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authString = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getPlugins_args')
    if self.authString is not None:
      oprot.writeFieldBegin('authString', TType.STRING, 1)
      oprot.writeString(self.authString)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getPlugins_result:
  """
  Attributes:
   - success
   - aex
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(Plugin, Plugin.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'aex', (EAuthException, EAuthException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, aex=None,):
    self.success = success
    self.aex = aex

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype124, _size121) = iprot.readListBegin()
          for _i125 in xrange(_size121):
            _elem126 = Plugin()
            _elem126.read(iprot)
            self.success.append(_elem126)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.aex = EAuthException()
          self.aex.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getPlugins_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter127 in self.success:
        iter127.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.aex is not None:
      oprot.writeFieldBegin('aex', TType.STRUCT, 1)
      self.aex.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getServer_args:
  """
  Attributes:
   - authString
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authString', None, None, ), # 1
  )

  def __init__(self, authString=None,):
    self.authString = authString

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authString = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getServer_args')
    if self.authString is not None:
      oprot.writeFieldBegin('authString', TType.STRING, 1)
      oprot.writeString(self.authString)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getServer_result:
  """
  Attributes:
   - success
   - aex
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Server, Server.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'aex', (EAuthException, EAuthException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, aex=None,):
    self.success = success
    self.aex = aex

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Server()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.aex = EAuthException()
          self.aex.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getServer_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.aex is not None:
      oprot.writeFieldBegin('aex', TType.STRUCT, 1)
      self.aex.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getServerVersion_args:
  """
  Attributes:
   - authString
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authString', None, None, ), # 1
  )

  def __init__(self, authString=None,):
    self.authString = authString

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authString = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getServerVersion_args')
    if self.authString is not None:
      oprot.writeFieldBegin('authString', TType.STRING, 1)
      oprot.writeString(self.authString)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getServerVersion_result:
  """
  Attributes:
   - success
   - aex
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'aex', (EAuthException, EAuthException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, aex=None,):
    self.success = success
    self.aex = aex

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.aex = EAuthException()
          self.aex.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getServerVersion_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.aex is not None:
      oprot.writeFieldBegin('aex', TType.STRUCT, 1)
      self.aex.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getWhitelist_args:
  """
  Attributes:
   - authString
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authString', None, None, ), # 1
  )

  def __init__(self, authString=None,):
    self.authString = authString

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authString = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getWhitelist_args')
    if self.authString is not None:
      oprot.writeFieldBegin('authString', TType.STRING, 1)
      oprot.writeString(self.authString)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getWhitelist_result:
  """
  Attributes:
   - success
   - aex
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(OfflinePlayer, OfflinePlayer.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'aex', (EAuthException, EAuthException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, aex=None,):
    self.success = success
    self.aex = aex

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype131, _size128) = iprot.readListBegin()
          for _i132 in xrange(_size128):
            _elem133 = OfflinePlayer()
            _elem133.read(iprot)
            self.success.append(_elem133)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.aex = EAuthException()
          self.aex.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getWhitelist_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter134 in self.success:
        iter134.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.aex is not None:
      oprot.writeFieldBegin('aex', TType.STRUCT, 1)
      self.aex.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getWorld_args:
  """
  Attributes:
   - authString
   - worldName
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authString', None, None, ), # 1
    (2, TType.STRING, 'worldName', None, None, ), # 2
  )

  def __init__(self, authString=None, worldName=None,):
    self.authString = authString
    self.worldName = worldName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authString = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.worldName = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getWorld_args')
    if self.authString is not None:
      oprot.writeFieldBegin('authString', TType.STRING, 1)
      oprot.writeString(self.authString)
      oprot.writeFieldEnd()
    if self.worldName is not None:
      oprot.writeFieldBegin('worldName', TType.STRING, 2)
      oprot.writeString(self.worldName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getWorld_result:
  """
  Attributes:
   - success
   - aex
   - dex
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (World, World.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'aex', (EAuthException, EAuthException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'dex', (EDataException, EDataException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, aex=None, dex=None,):
    self.success = success
    self.aex = aex
    self.dex = dex

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = World()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.aex = EAuthException()
          self.aex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dex = EDataException()
          self.dex.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getWorld_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.aex is not None:
      oprot.writeFieldBegin('aex', TType.STRUCT, 1)
      self.aex.write(oprot)
      oprot.writeFieldEnd()
    if self.dex is not None:
      oprot.writeFieldBegin('dex', TType.STRUCT, 2)
      self.dex.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getWorlds_args:
  """
  Attributes:
   - authString
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authString', None, None, ), # 1
  )

  def __init__(self, authString=None,):
    self.authString = authString

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authString = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getWorlds_args')
    if self.authString is not None:
      oprot.writeFieldBegin('authString', TType.STRING, 1)
      oprot.writeString(self.authString)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getWorlds_result:
  """
  Attributes:
   - success
   - aex
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(World, World.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'aex', (EAuthException, EAuthException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, aex=None,):
    self.success = success
    self.aex = aex

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype138, _size135) = iprot.readListBegin()
          for _i139 in xrange(_size135):
            _elem140 = World()
            _elem140.read(iprot)
            self.success.append(_elem140)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.aex = EAuthException()
          self.aex.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getWorlds_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter141 in self.success:
        iter141.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.aex is not None:
      oprot.writeFieldBegin('aex', TType.STRUCT, 1)
      self.aex.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class installPlugin_args:
  """
  Attributes:
   - authString
   - downloadUrl
   - md5
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authString', None, None, ), # 1
    (2, TType.STRING, 'downloadUrl', None, None, ), # 2
    (3, TType.STRING, 'md5', None, None, ), # 3
  )

  def __init__(self, authString=None, downloadUrl=None, md5=None,):
    self.authString = authString
    self.downloadUrl = downloadUrl
    self.md5 = md5

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authString = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.downloadUrl = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.md5 = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('installPlugin_args')
    if self.authString is not None:
      oprot.writeFieldBegin('authString', TType.STRING, 1)
      oprot.writeString(self.authString)
      oprot.writeFieldEnd()
    if self.downloadUrl is not None:
      oprot.writeFieldBegin('downloadUrl', TType.STRING, 2)
      oprot.writeString(self.downloadUrl)
      oprot.writeFieldEnd()
    if self.md5 is not None:
      oprot.writeFieldBegin('md5', TType.STRING, 3)
      oprot.writeString(self.md5)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class installPlugin_result:
  """
  Attributes:
   - success
   - aex
   - dex
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'aex', (EAuthException, EAuthException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'dex', (EDataException, EDataException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, aex=None, dex=None,):
    self.success = success
    self.aex = aex
    self.dex = dex

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.aex = EAuthException()
          self.aex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dex = EDataException()
          self.dex.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('installPlugin_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.aex is not None:
      oprot.writeFieldBegin('aex', TType.STRUCT, 1)
      self.aex.write(oprot)
      oprot.writeFieldEnd()
    if self.dex is not None:
      oprot.writeFieldBegin('dex', TType.STRUCT, 2)
      self.dex.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class kick_args:
  """
  Attributes:
   - authString
   - name
   - message
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authString', None, None, ), # 1
    (2, TType.STRING, 'name', None, None, ), # 2
    (3, TType.STRING, 'message', None, None, ), # 3
  )

  def __init__(self, authString=None, name=None, message=None,):
    self.authString = authString
    self.name = name
    self.message = message

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authString = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.message = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('kick_args')
    if self.authString is not None:
      oprot.writeFieldBegin('authString', TType.STRING, 1)
      oprot.writeString(self.authString)
      oprot.writeFieldEnd()
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 2)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 3)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class kick_result:
  """
  Attributes:
   - success
   - aex
   - dex
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'aex', (EAuthException, EAuthException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'dex', (EDataException, EDataException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, aex=None, dex=None,):
    self.success = success
    self.aex = aex
    self.dex = dex

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.aex = EAuthException()
          self.aex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dex = EDataException()
          self.dex.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('kick_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.aex is not None:
      oprot.writeFieldBegin('aex', TType.STRUCT, 1)
      self.aex.write(oprot)
      oprot.writeFieldEnd()
    if self.dex is not None:
      oprot.writeFieldBegin('dex', TType.STRUCT, 2)
      self.dex.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class op_args:
  """
  Attributes:
   - authString
   - name
   - notifyPlayer
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authString', None, None, ), # 1
    (2, TType.STRING, 'name', None, None, ), # 2
    (3, TType.BOOL, 'notifyPlayer', None, None, ), # 3
  )

  def __init__(self, authString=None, name=None, notifyPlayer=None,):
    self.authString = authString
    self.name = name
    self.notifyPlayer = notifyPlayer

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authString = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.notifyPlayer = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('op_args')
    if self.authString is not None:
      oprot.writeFieldBegin('authString', TType.STRING, 1)
      oprot.writeString(self.authString)
      oprot.writeFieldEnd()
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 2)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.notifyPlayer is not None:
      oprot.writeFieldBegin('notifyPlayer', TType.BOOL, 3)
      oprot.writeBool(self.notifyPlayer)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class op_result:
  """
  Attributes:
   - success
   - aex
   - dex
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'aex', (EAuthException, EAuthException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'dex', (EDataException, EDataException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, aex=None, dex=None,):
    self.success = success
    self.aex = aex
    self.dex = dex

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.aex = EAuthException()
          self.aex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dex = EDataException()
          self.dex.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('op_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.aex is not None:
      oprot.writeFieldBegin('aex', TType.STRUCT, 1)
      self.aex.write(oprot)
      oprot.writeFieldEnd()
    if self.dex is not None:
      oprot.writeFieldBegin('dex', TType.STRUCT, 2)
      self.dex.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ping_args:
  """
  Attributes:
   - authString
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authString', None, None, ), # 1
  )

  def __init__(self, authString=None,):
    self.authString = authString

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authString = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ping_args')
    if self.authString is not None:
      oprot.writeFieldBegin('authString', TType.STRING, 1)
      oprot.writeString(self.authString)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ping_result:
  """
  Attributes:
   - success
   - aex
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'aex', (EAuthException, EAuthException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, aex=None,):
    self.success = success
    self.aex = aex

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.aex = EAuthException()
          self.aex.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ping_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.aex is not None:
      oprot.writeFieldBegin('aex', TType.STRUCT, 1)
      self.aex.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class reloadServer_args:
  """
  Attributes:
   - authString
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authString', None, None, ), # 1
  )

  def __init__(self, authString=None,):
    self.authString = authString

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authString = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('reloadServer_args')
    if self.authString is not None:
      oprot.writeFieldBegin('authString', TType.STRING, 1)
      oprot.writeString(self.authString)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class removeInventoryItem_args:
  """
  Attributes:
   - authString
   - playerName
   - itemIndex
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authString', None, None, ), # 1
    (2, TType.STRING, 'playerName', None, None, ), # 2
    (3, TType.I32, 'itemIndex', None, None, ), # 3
  )

  def __init__(self, authString=None, playerName=None, itemIndex=None,):
    self.authString = authString
    self.playerName = playerName
    self.itemIndex = itemIndex

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authString = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.playerName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.itemIndex = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('removeInventoryItem_args')
    if self.authString is not None:
      oprot.writeFieldBegin('authString', TType.STRING, 1)
      oprot.writeString(self.authString)
      oprot.writeFieldEnd()
    if self.playerName is not None:
      oprot.writeFieldBegin('playerName', TType.STRING, 2)
      oprot.writeString(self.playerName)
      oprot.writeFieldEnd()
    if self.itemIndex is not None:
      oprot.writeFieldBegin('itemIndex', TType.I32, 3)
      oprot.writeI32(self.itemIndex)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class removeInventoryItem_result:
  """
  Attributes:
   - success
   - aex
   - dex
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'aex', (EAuthException, EAuthException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'dex', (EDataException, EDataException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, aex=None, dex=None,):
    self.success = success
    self.aex = aex
    self.dex = dex

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.aex = EAuthException()
          self.aex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dex = EDataException()
          self.dex.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('removeInventoryItem_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.aex is not None:
      oprot.writeFieldBegin('aex', TType.STRUCT, 1)
      self.aex.write(oprot)
      oprot.writeFieldEnd()
    if self.dex is not None:
      oprot.writeFieldBegin('dex', TType.STRUCT, 2)
      self.dex.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class removeFromWhitelist_args:
  """
  Attributes:
   - authString
   - name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authString', None, None, ), # 1
    (2, TType.STRING, 'name', None, None, ), # 2
  )

  def __init__(self, authString=None, name=None,):
    self.authString = authString
    self.name = name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authString = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.name = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('removeFromWhitelist_args')
    if self.authString is not None:
      oprot.writeFieldBegin('authString', TType.STRING, 1)
      oprot.writeString(self.authString)
      oprot.writeFieldEnd()
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 2)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class removeFromWhitelist_result:
  """
  Attributes:
   - success
   - aex
   - dex
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'aex', (EAuthException, EAuthException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'dex', (EDataException, EDataException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, aex=None, dex=None,):
    self.success = success
    self.aex = aex
    self.dex = dex

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.aex = EAuthException()
          self.aex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dex = EDataException()
          self.dex.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('removeFromWhitelist_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.aex is not None:
      oprot.writeFieldBegin('aex', TType.STRUCT, 1)
      self.aex.write(oprot)
      oprot.writeFieldEnd()
    if self.dex is not None:
      oprot.writeFieldBegin('dex', TType.STRUCT, 2)
      self.dex.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class replacePlugin_args:
  """
  Attributes:
   - authString
   - pluginName
   - downloadUrl
   - md5
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authString', None, None, ), # 1
    (2, TType.STRING, 'pluginName', None, None, ), # 2
    (3, TType.STRING, 'downloadUrl', None, None, ), # 3
    (4, TType.STRING, 'md5', None, None, ), # 4
  )

  def __init__(self, authString=None, pluginName=None, downloadUrl=None, md5=None,):
    self.authString = authString
    self.pluginName = pluginName
    self.downloadUrl = downloadUrl
    self.md5 = md5

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authString = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.pluginName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.downloadUrl = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.md5 = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('replacePlugin_args')
    if self.authString is not None:
      oprot.writeFieldBegin('authString', TType.STRING, 1)
      oprot.writeString(self.authString)
      oprot.writeFieldEnd()
    if self.pluginName is not None:
      oprot.writeFieldBegin('pluginName', TType.STRING, 2)
      oprot.writeString(self.pluginName)
      oprot.writeFieldEnd()
    if self.downloadUrl is not None:
      oprot.writeFieldBegin('downloadUrl', TType.STRING, 3)
      oprot.writeString(self.downloadUrl)
      oprot.writeFieldEnd()
    if self.md5 is not None:
      oprot.writeFieldBegin('md5', TType.STRING, 4)
      oprot.writeString(self.md5)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class replacePlugin_result:
  """
  Attributes:
   - success
   - aex
   - dex
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'aex', (EAuthException, EAuthException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'dex', (EDataException, EDataException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, aex=None, dex=None,):
    self.success = success
    self.aex = aex
    self.dex = dex

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.aex = EAuthException()
          self.aex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dex = EDataException()
          self.dex.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('replacePlugin_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.aex is not None:
      oprot.writeFieldBegin('aex', TType.STRUCT, 1)
      self.aex.write(oprot)
      oprot.writeFieldEnd()
    if self.dex is not None:
      oprot.writeFieldBegin('dex', TType.STRUCT, 2)
      self.dex.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class runConsoleCommand_args:
  """
  Attributes:
   - authString
   - command
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authString', None, None, ), # 1
    (2, TType.STRING, 'command', None, None, ), # 2
  )

  def __init__(self, authString=None, command=None,):
    self.authString = authString
    self.command = command

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authString = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.command = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('runConsoleCommand_args')
    if self.authString is not None:
      oprot.writeFieldBegin('authString', TType.STRING, 1)
      oprot.writeString(self.authString)
      oprot.writeFieldEnd()
    if self.command is not None:
      oprot.writeFieldBegin('command', TType.STRING, 2)
      oprot.writeString(self.command)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class saveWorld_args:
  """
  Attributes:
   - authString
   - worldName
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authString', None, None, ), # 1
    (2, TType.STRING, 'worldName', None, None, ), # 2
  )

  def __init__(self, authString=None, worldName=None,):
    self.authString = authString
    self.worldName = worldName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authString = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.worldName = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('saveWorld_args')
    if self.authString is not None:
      oprot.writeFieldBegin('authString', TType.STRING, 1)
      oprot.writeString(self.authString)
      oprot.writeFieldEnd()
    if self.worldName is not None:
      oprot.writeFieldBegin('worldName', TType.STRING, 2)
      oprot.writeString(self.worldName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class saveWorld_result:
  """
  Attributes:
   - success
   - aex
   - dex
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'aex', (EAuthException, EAuthException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'dex', (EDataException, EDataException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, aex=None, dex=None,):
    self.success = success
    self.aex = aex
    self.dex = dex

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.aex = EAuthException()
          self.aex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dex = EDataException()
          self.dex.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('saveWorld_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.aex is not None:
      oprot.writeFieldBegin('aex', TType.STRUCT, 1)
      self.aex.write(oprot)
      oprot.writeFieldEnd()
    if self.dex is not None:
      oprot.writeFieldBegin('dex', TType.STRUCT, 2)
      self.dex.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class setFileContents_args:
  """
  Attributes:
   - authString
   - fileName
   - fileContents
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authString', None, None, ), # 1
    (2, TType.STRING, 'fileName', None, None, ), # 2
    (3, TType.STRING, 'fileContents', None, None, ), # 3
  )

  def __init__(self, authString=None, fileName=None, fileContents=None,):
    self.authString = authString
    self.fileName = fileName
    self.fileContents = fileContents

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authString = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.fileName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.fileContents = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('setFileContents_args')
    if self.authString is not None:
      oprot.writeFieldBegin('authString', TType.STRING, 1)
      oprot.writeString(self.authString)
      oprot.writeFieldEnd()
    if self.fileName is not None:
      oprot.writeFieldBegin('fileName', TType.STRING, 2)
      oprot.writeString(self.fileName)
      oprot.writeFieldEnd()
    if self.fileContents is not None:
      oprot.writeFieldBegin('fileContents', TType.STRING, 3)
      oprot.writeString(self.fileContents)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class setFileContents_result:
  """
  Attributes:
   - success
   - aex
   - dex
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'aex', (EAuthException, EAuthException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'dex', (EDataException, EDataException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, aex=None, dex=None,):
    self.success = success
    self.aex = aex
    self.dex = dex

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.aex = EAuthException()
          self.aex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dex = EDataException()
          self.dex.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('setFileContents_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.aex is not None:
      oprot.writeFieldBegin('aex', TType.STRUCT, 1)
      self.aex.write(oprot)
      oprot.writeFieldEnd()
    if self.dex is not None:
      oprot.writeFieldBegin('dex', TType.STRUCT, 2)
      self.dex.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class setGameMode_args:
  """
  Attributes:
   - authString
   - name
   - mode
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authString', None, None, ), # 1
    (2, TType.STRING, 'name', None, None, ), # 2
    (3, TType.I32, 'mode', None, None, ), # 3
  )

  def __init__(self, authString=None, name=None, mode=None,):
    self.authString = authString
    self.name = name
    self.mode = mode

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authString = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.mode = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('setGameMode_args')
    if self.authString is not None:
      oprot.writeFieldBegin('authString', TType.STRING, 1)
      oprot.writeString(self.authString)
      oprot.writeFieldEnd()
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 2)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.mode is not None:
      oprot.writeFieldBegin('mode', TType.I32, 3)
      oprot.writeI32(self.mode)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class setGameMode_result:
  """
  Attributes:
   - success
   - aex
   - dex
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'aex', (EAuthException, EAuthException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'dex', (EDataException, EDataException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, aex=None, dex=None,):
    self.success = success
    self.aex = aex
    self.dex = dex

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.aex = EAuthException()
          self.aex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dex = EDataException()
          self.dex.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('setGameMode_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.aex is not None:
      oprot.writeFieldBegin('aex', TType.STRUCT, 1)
      self.aex.write(oprot)
      oprot.writeFieldEnd()
    if self.dex is not None:
      oprot.writeFieldBegin('dex', TType.STRUCT, 2)
      self.dex.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class setPvp_args:
  """
  Attributes:
   - authString
   - worldName
   - isPvp
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authString', None, None, ), # 1
    (2, TType.STRING, 'worldName', None, None, ), # 2
    (3, TType.BOOL, 'isPvp', None, None, ), # 3
  )

  def __init__(self, authString=None, worldName=None, isPvp=None,):
    self.authString = authString
    self.worldName = worldName
    self.isPvp = isPvp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authString = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.worldName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.isPvp = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('setPvp_args')
    if self.authString is not None:
      oprot.writeFieldBegin('authString', TType.STRING, 1)
      oprot.writeString(self.authString)
      oprot.writeFieldEnd()
    if self.worldName is not None:
      oprot.writeFieldBegin('worldName', TType.STRING, 2)
      oprot.writeString(self.worldName)
      oprot.writeFieldEnd()
    if self.isPvp is not None:
      oprot.writeFieldBegin('isPvp', TType.BOOL, 3)
      oprot.writeBool(self.isPvp)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class setPvp_result:
  """
  Attributes:
   - success
   - aex
   - dex
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'aex', (EAuthException, EAuthException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'dex', (EDataException, EDataException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, aex=None, dex=None,):
    self.success = success
    self.aex = aex
    self.dex = dex

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.aex = EAuthException()
          self.aex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dex = EDataException()
          self.dex.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('setPvp_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.aex is not None:
      oprot.writeFieldBegin('aex', TType.STRUCT, 1)
      self.aex.write(oprot)
      oprot.writeFieldEnd()
    if self.dex is not None:
      oprot.writeFieldBegin('dex', TType.STRUCT, 2)
      self.dex.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class setStorm_args:
  """
  Attributes:
   - authString
   - worldName
   - hasStorm
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authString', None, None, ), # 1
    (2, TType.STRING, 'worldName', None, None, ), # 2
    (3, TType.BOOL, 'hasStorm', None, None, ), # 3
  )

  def __init__(self, authString=None, worldName=None, hasStorm=None,):
    self.authString = authString
    self.worldName = worldName
    self.hasStorm = hasStorm

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authString = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.worldName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.hasStorm = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('setStorm_args')
    if self.authString is not None:
      oprot.writeFieldBegin('authString', TType.STRING, 1)
      oprot.writeString(self.authString)
      oprot.writeFieldEnd()
    if self.worldName is not None:
      oprot.writeFieldBegin('worldName', TType.STRING, 2)
      oprot.writeString(self.worldName)
      oprot.writeFieldEnd()
    if self.hasStorm is not None:
      oprot.writeFieldBegin('hasStorm', TType.BOOL, 3)
      oprot.writeBool(self.hasStorm)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class setStorm_result:
  """
  Attributes:
   - success
   - aex
   - dex
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'aex', (EAuthException, EAuthException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'dex', (EDataException, EDataException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, aex=None, dex=None,):
    self.success = success
    self.aex = aex
    self.dex = dex

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.aex = EAuthException()
          self.aex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dex = EDataException()
          self.dex.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('setStorm_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.aex is not None:
      oprot.writeFieldBegin('aex', TType.STRUCT, 1)
      self.aex.write(oprot)
      oprot.writeFieldEnd()
    if self.dex is not None:
      oprot.writeFieldBegin('dex', TType.STRUCT, 2)
      self.dex.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class setThundering_args:
  """
  Attributes:
   - authString
   - worldName
   - isThundering
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authString', None, None, ), # 1
    (2, TType.STRING, 'worldName', None, None, ), # 2
    (3, TType.BOOL, 'isThundering', None, None, ), # 3
  )

  def __init__(self, authString=None, worldName=None, isThundering=None,):
    self.authString = authString
    self.worldName = worldName
    self.isThundering = isThundering

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authString = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.worldName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.isThundering = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('setThundering_args')
    if self.authString is not None:
      oprot.writeFieldBegin('authString', TType.STRING, 1)
      oprot.writeString(self.authString)
      oprot.writeFieldEnd()
    if self.worldName is not None:
      oprot.writeFieldBegin('worldName', TType.STRING, 2)
      oprot.writeString(self.worldName)
      oprot.writeFieldEnd()
    if self.isThundering is not None:
      oprot.writeFieldBegin('isThundering', TType.BOOL, 3)
      oprot.writeBool(self.isThundering)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class setThundering_result:
  """
  Attributes:
   - success
   - aex
   - dex
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'aex', (EAuthException, EAuthException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'dex', (EDataException, EDataException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, aex=None, dex=None,):
    self.success = success
    self.aex = aex
    self.dex = dex

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.aex = EAuthException()
          self.aex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dex = EDataException()
          self.dex.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('setThundering_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.aex is not None:
      oprot.writeFieldBegin('aex', TType.STRUCT, 1)
      self.aex.write(oprot)
      oprot.writeFieldEnd()
    if self.dex is not None:
      oprot.writeFieldBegin('dex', TType.STRUCT, 2)
      self.dex.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class setWorldTime_args:
  """
  Attributes:
   - authString
   - worldName
   - time
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authString', None, None, ), # 1
    (2, TType.STRING, 'worldName', None, None, ), # 2
    (3, TType.I64, 'time', None, None, ), # 3
  )

  def __init__(self, authString=None, worldName=None, time=None,):
    self.authString = authString
    self.worldName = worldName
    self.time = time

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authString = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.worldName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.time = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('setWorldTime_args')
    if self.authString is not None:
      oprot.writeFieldBegin('authString', TType.STRING, 1)
      oprot.writeString(self.authString)
      oprot.writeFieldEnd()
    if self.worldName is not None:
      oprot.writeFieldBegin('worldName', TType.STRING, 2)
      oprot.writeString(self.worldName)
      oprot.writeFieldEnd()
    if self.time is not None:
      oprot.writeFieldBegin('time', TType.I64, 3)
      oprot.writeI64(self.time)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class setWorldTime_result:
  """
  Attributes:
   - success
   - aex
   - dex
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'aex', (EAuthException, EAuthException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'dex', (EDataException, EDataException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, aex=None, dex=None,):
    self.success = success
    self.aex = aex
    self.dex = dex

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.aex = EAuthException()
          self.aex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dex = EDataException()
          self.dex.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('setWorldTime_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.aex is not None:
      oprot.writeFieldBegin('aex', TType.STRUCT, 1)
      self.aex.write(oprot)
      oprot.writeFieldEnd()
    if self.dex is not None:
      oprot.writeFieldBegin('dex', TType.STRUCT, 2)
      self.dex.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class unBan_args:
  """
  Attributes:
   - authString
   - name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authString', None, None, ), # 1
    (2, TType.STRING, 'name', None, None, ), # 2
  )

  def __init__(self, authString=None, name=None,):
    self.authString = authString
    self.name = name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authString = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.name = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('unBan_args')
    if self.authString is not None:
      oprot.writeFieldBegin('authString', TType.STRING, 1)
      oprot.writeString(self.authString)
      oprot.writeFieldEnd()
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 2)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class unBan_result:
  """
  Attributes:
   - success
   - aex
   - dex
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'aex', (EAuthException, EAuthException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'dex', (EDataException, EDataException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, aex=None, dex=None,):
    self.success = success
    self.aex = aex
    self.dex = dex

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.aex = EAuthException()
          self.aex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dex = EDataException()
          self.dex.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('unBan_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.aex is not None:
      oprot.writeFieldBegin('aex', TType.STRUCT, 1)
      self.aex.write(oprot)
      oprot.writeFieldEnd()
    if self.dex is not None:
      oprot.writeFieldBegin('dex', TType.STRUCT, 2)
      self.dex.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class unBanIp_args:
  """
  Attributes:
   - authString
   - ip
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authString', None, None, ), # 1
    (2, TType.STRING, 'ip', None, None, ), # 2
  )

  def __init__(self, authString=None, ip=None,):
    self.authString = authString
    self.ip = ip

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authString = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ip = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('unBanIp_args')
    if self.authString is not None:
      oprot.writeFieldBegin('authString', TType.STRING, 1)
      oprot.writeString(self.authString)
      oprot.writeFieldEnd()
    if self.ip is not None:
      oprot.writeFieldBegin('ip', TType.STRING, 2)
      oprot.writeString(self.ip)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class unBanIp_result:
  """
  Attributes:
   - success
   - aex
   - dex
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'aex', (EAuthException, EAuthException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'dex', (EDataException, EDataException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, aex=None, dex=None,):
    self.success = success
    self.aex = aex
    self.dex = dex

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.aex = EAuthException()
          self.aex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dex = EDataException()
          self.dex.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('unBanIp_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.aex is not None:
      oprot.writeFieldBegin('aex', TType.STRUCT, 1)
      self.aex.write(oprot)
      oprot.writeFieldEnd()
    if self.dex is not None:
      oprot.writeFieldBegin('dex', TType.STRUCT, 2)
      self.dex.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class updateInventoryItem_args:
  """
  Attributes:
   - authString
   - playerName
   - item
   - itemIndex
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authString', None, None, ), # 1
    (2, TType.STRING, 'playerName', None, None, ), # 2
    (3, TType.STRUCT, 'item', (ItemStack, ItemStack.thrift_spec), None, ), # 3
    (4, TType.I32, 'itemIndex', None, None, ), # 4
  )

  def __init__(self, authString=None, playerName=None, item=None, itemIndex=None,):
    self.authString = authString
    self.playerName = playerName
    self.item = item
    self.itemIndex = itemIndex

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authString = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.playerName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.item = ItemStack()
          self.item.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.itemIndex = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('updateInventoryItem_args')
    if self.authString is not None:
      oprot.writeFieldBegin('authString', TType.STRING, 1)
      oprot.writeString(self.authString)
      oprot.writeFieldEnd()
    if self.playerName is not None:
      oprot.writeFieldBegin('playerName', TType.STRING, 2)
      oprot.writeString(self.playerName)
      oprot.writeFieldEnd()
    if self.item is not None:
      oprot.writeFieldBegin('item', TType.STRUCT, 3)
      self.item.write(oprot)
      oprot.writeFieldEnd()
    if self.itemIndex is not None:
      oprot.writeFieldBegin('itemIndex', TType.I32, 4)
      oprot.writeI32(self.itemIndex)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class updateInventoryItem_result:
  """
  Attributes:
   - success
   - aex
   - dex
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'aex', (EAuthException, EAuthException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'dex', (EDataException, EDataException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, aex=None, dex=None,):
    self.success = success
    self.aex = aex
    self.dex = dex

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.aex = EAuthException()
          self.aex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dex = EDataException()
          self.dex.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('updateInventoryItem_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.aex is not None:
      oprot.writeFieldBegin('aex', TType.STRUCT, 1)
      self.aex.write(oprot)
      oprot.writeFieldEnd()
    if self.dex is not None:
      oprot.writeFieldBegin('dex', TType.STRUCT, 2)
      self.dex.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
