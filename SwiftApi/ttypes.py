#
# Autogenerated by Thrift Compiler (0.9.1)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException

from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class ErrorCode:
  """
  Various codes used for catching errors
  """
  INVALID_REQUEST = 0
  INVALID_AUTHSTRING = 1
  NOT_FOUND = 2
  DOWNLOAD_ERROR = 3
  FILE_ERROR = 4
  NO_READ = 5

  _VALUES_TO_NAMES = {
    0: "INVALID_REQUEST",
    1: "INVALID_AUTHSTRING",
    2: "NOT_FOUND",
    3: "DOWNLOAD_ERROR",
    4: "FILE_ERROR",
    5: "NO_READ",
  }

  _NAMES_TO_VALUES = {
    "INVALID_REQUEST": 0,
    "INVALID_AUTHSTRING": 1,
    "NOT_FOUND": 2,
    "DOWNLOAD_ERROR": 3,
    "FILE_ERROR": 4,
    "NO_READ": 5,
  }

class Difficulty:
  """
  Game difficulties
  """
  PEACEFUL = 0
  EASY = 1
  NORMAL = 2
  HARD = 3

  _VALUES_TO_NAMES = {
    0: "PEACEFUL",
    1: "EASY",
    2: "NORMAL",
    3: "HARD",
  }

  _NAMES_TO_VALUES = {
    "PEACEFUL": 0,
    "EASY": 1,
    "NORMAL": 2,
    "HARD": 3,
  }

class Environment:
  """
  Represents various map environment types that a world may be
  """
  NETHER = 0
  NORMAL = 1
  THE_END = 2

  _VALUES_TO_NAMES = {
    0: "NETHER",
    1: "NORMAL",
    2: "THE_END",
  }

  _NAMES_TO_VALUES = {
    "NETHER": 0,
    "NORMAL": 1,
    "THE_END": 2,
  }

class GameMode:
  """
  Valid game modes
  """
  SURVIVAL = 0
  CREATIVE = 1
  ADVENTURE = 2

  _VALUES_TO_NAMES = {
    0: "SURVIVAL",
    1: "CREATIVE",
    2: "ADVENTURE",
  }

  _NAMES_TO_VALUES = {
    "SURVIVAL": 0,
    "CREATIVE": 1,
    "ADVENTURE": 2,
  }

class Enchantment:
  """
  All enchantments
  """
  PROTECTION_ENVIRONMENTAL = 0
  PROTECTION_FIRE = 1
  PROTECTION_FALL = 2
  PROTECTION_EXPLOSIONS = 3
  PROTECTION_PROJECTILE = 4
  OXYGEN = 5
  WATER_WORKER = 6
  DAMAGE_ALL = 16
  DAMAGE_UNDEAD = 17
  DAMAGE_ARTHROPODS = 18
  KNOCKBACK = 19
  FIRE_ASPECT = 20
  LOOT_BONUS_MOBS = 21
  DIG_SPEED = 32
  SILK_TOUCH = 33
  DURABILITY = 34
  LOOT_BONUS_BLOCKS = 35
  ARROW_DAMAGE = 48
  ARROW_KNOCKBACK = 49
  ARROW_FIRE = 50
  ARROW_INFINITE = 51

  _VALUES_TO_NAMES = {
    0: "PROTECTION_ENVIRONMENTAL",
    1: "PROTECTION_FIRE",
    2: "PROTECTION_FALL",
    3: "PROTECTION_EXPLOSIONS",
    4: "PROTECTION_PROJECTILE",
    5: "OXYGEN",
    6: "WATER_WORKER",
    16: "DAMAGE_ALL",
    17: "DAMAGE_UNDEAD",
    18: "DAMAGE_ARTHROPODS",
    19: "KNOCKBACK",
    20: "FIRE_ASPECT",
    21: "LOOT_BONUS_MOBS",
    32: "DIG_SPEED",
    33: "SILK_TOUCH",
    34: "DURABILITY",
    35: "LOOT_BONUS_BLOCKS",
    48: "ARROW_DAMAGE",
    49: "ARROW_KNOCKBACK",
    50: "ARROW_FIRE",
    51: "ARROW_INFINITE",
  }

  _NAMES_TO_VALUES = {
    "PROTECTION_ENVIRONMENTAL": 0,
    "PROTECTION_FIRE": 1,
    "PROTECTION_FALL": 2,
    "PROTECTION_EXPLOSIONS": 3,
    "PROTECTION_PROJECTILE": 4,
    "OXYGEN": 5,
    "WATER_WORKER": 6,
    "DAMAGE_ALL": 16,
    "DAMAGE_UNDEAD": 17,
    "DAMAGE_ARTHROPODS": 18,
    "KNOCKBACK": 19,
    "FIRE_ASPECT": 20,
    "LOOT_BONUS_MOBS": 21,
    "DIG_SPEED": 32,
    "SILK_TOUCH": 33,
    "DURABILITY": 34,
    "LOOT_BONUS_BLOCKS": 35,
    "ARROW_DAMAGE": 48,
    "ARROW_KNOCKBACK": 49,
    "ARROW_FIRE": 50,
    "ARROW_INFINITE": 51,
  }


class EDataException(TException):
  """
  This exception is thrown when something data-related went wrong

  Attributes:
   - code: Detailed reason for the exception
   - errorMessage: A message that describes the exception
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'code', None, None, ), # 1
    (2, TType.STRING, 'errorMessage', None, None, ), # 2
  )

  def __init__(self, code=None, errorMessage=None,):
    self.code = code
    self.errorMessage = errorMessage

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.code = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.errorMessage = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('EDataException')
    if self.code is not None:
      oprot.writeFieldBegin('code', TType.I32, 1)
      oprot.writeI32(self.code)
      oprot.writeFieldEnd()
    if self.errorMessage is not None:
      oprot.writeFieldBegin('errorMessage', TType.STRING, 2)
      oprot.writeString(self.errorMessage)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class EAuthException(TException):
  """
  Thrown when authentication fails, this is thrown

  Attributes:
   - code: Detailed reason for the exception
   - errorMessage: A message that describes the exception
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'code', None, None, ), # 1
    (2, TType.STRING, 'errorMessage', None, None, ), # 2
  )

  def __init__(self, code=None, errorMessage=None,):
    self.code = code
    self.errorMessage = errorMessage

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.code = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.errorMessage = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('EAuthException')
    if self.code is not None:
      oprot.writeFieldBegin('code', TType.I32, 1)
      oprot.writeI32(self.code)
      oprot.writeFieldEnd()
    if self.errorMessage is not None:
      oprot.writeFieldBegin('errorMessage', TType.STRING, 2)
      oprot.writeString(self.errorMessage)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ConsoleLine:
  """
  A line from the console

  Attributes:
   - timestamp: A unix-style timestamp (in milliseconds)
   - message: The actual message from the console
   - level: The log level (INFO, WARN, SEVERE etc.)
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'timestamp', None, None, ), # 1
    (2, TType.STRING, 'message', None, None, ), # 2
    (3, TType.STRING, 'level', None, None, ), # 3
  )

  def __init__(self, timestamp=None, message=None, level=None,):
    self.timestamp = timestamp
    self.message = message
    self.level = level

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.message = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.level = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ConsoleLine')
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 1)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 2)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    if self.level is not None:
      oprot.writeFieldBegin('level', TType.STRING, 3)
      oprot.writeString(self.level)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Location:
  """
  An object that represents a location in the game world

  Attributes:
   - x: The X coordinate
   - y: The Y coordinate (height)
   - z: The Z coordinate
   - pitch: The pitch (vertical rotation)
   - yaw: The yaw (lateral rotation)
  """

  thrift_spec = (
    None, # 0
    (1, TType.DOUBLE, 'x', None, None, ), # 1
    (2, TType.DOUBLE, 'y', None, None, ), # 2
    (3, TType.DOUBLE, 'z', None, None, ), # 3
    (4, TType.DOUBLE, 'pitch', None, None, ), # 4
    (5, TType.DOUBLE, 'yaw', None, None, ), # 5
  )

  def __init__(self, x=None, y=None, z=None, pitch=None, yaw=None,):
    self.x = x
    self.y = y
    self.z = z
    self.pitch = pitch
    self.yaw = yaw

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.DOUBLE:
          self.x = iprot.readDouble();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.DOUBLE:
          self.y = iprot.readDouble();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.DOUBLE:
          self.z = iprot.readDouble();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.DOUBLE:
          self.pitch = iprot.readDouble();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.DOUBLE:
          self.yaw = iprot.readDouble();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Location')
    if self.x is not None:
      oprot.writeFieldBegin('x', TType.DOUBLE, 1)
      oprot.writeDouble(self.x)
      oprot.writeFieldEnd()
    if self.y is not None:
      oprot.writeFieldBegin('y', TType.DOUBLE, 2)
      oprot.writeDouble(self.y)
      oprot.writeFieldEnd()
    if self.z is not None:
      oprot.writeFieldBegin('z', TType.DOUBLE, 3)
      oprot.writeDouble(self.z)
      oprot.writeFieldEnd()
    if self.pitch is not None:
      oprot.writeFieldBegin('pitch', TType.DOUBLE, 4)
      oprot.writeDouble(self.pitch)
      oprot.writeFieldEnd()
    if self.yaw is not None:
      oprot.writeFieldBegin('yaw', TType.DOUBLE, 5)
      oprot.writeDouble(self.yaw)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ItemStack:
  """
  A stack of items

  Attributes:
   - amount: How many of this item are currently in the stack
   - typeId: The type ID of the item
   - durability: The durability of the item
   - enchantments: The current enchantments in effect on this item
   - lore: The lore associated with this item
  @since 1.5
   - displayName: The display name of the item
  @since 1.5
   - data: The data value associated with this item
  @since 1.5
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'amount', None, None, ), # 1
    (2, TType.I32, 'typeId', None, None, ), # 2
    (3, TType.I32, 'durability', None, None, ), # 3
    (4, TType.MAP, 'enchantments', (TType.I32,None,TType.I32,None), None, ), # 4
    (5, TType.LIST, 'lore', (TType.STRING,None), None, ), # 5
    (6, TType.STRING, 'displayName', None, None, ), # 6
    (7, TType.I32, 'data', None, None, ), # 7
  )

  def __init__(self, amount=None, typeId=None, durability=None, enchantments=None, lore=None, displayName=None, data=None,):
    self.amount = amount
    self.typeId = typeId
    self.durability = durability
    self.enchantments = enchantments
    self.lore = lore
    self.displayName = displayName
    self.data = data

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.amount = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.typeId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.durability = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.MAP:
          self.enchantments = {}
          (_ktype1, _vtype2, _size0 ) = iprot.readMapBegin()
          for _i4 in xrange(_size0):
            _key5 = iprot.readI32();
            _val6 = iprot.readI32();
            self.enchantments[_key5] = _val6
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.lore = []
          (_etype10, _size7) = iprot.readListBegin()
          for _i11 in xrange(_size7):
            _elem12 = iprot.readString();
            self.lore.append(_elem12)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.displayName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I32:
          self.data = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ItemStack')
    if self.amount is not None:
      oprot.writeFieldBegin('amount', TType.I32, 1)
      oprot.writeI32(self.amount)
      oprot.writeFieldEnd()
    if self.typeId is not None:
      oprot.writeFieldBegin('typeId', TType.I32, 2)
      oprot.writeI32(self.typeId)
      oprot.writeFieldEnd()
    if self.durability is not None:
      oprot.writeFieldBegin('durability', TType.I32, 3)
      oprot.writeI32(self.durability)
      oprot.writeFieldEnd()
    if self.enchantments is not None:
      oprot.writeFieldBegin('enchantments', TType.MAP, 4)
      oprot.writeMapBegin(TType.I32, TType.I32, len(self.enchantments))
      for kiter13,viter14 in self.enchantments.items():
        oprot.writeI32(kiter13)
        oprot.writeI32(viter14)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.lore is not None:
      oprot.writeFieldBegin('lore', TType.LIST, 5)
      oprot.writeListBegin(TType.STRING, len(self.lore))
      for iter15 in self.lore:
        oprot.writeString(iter15)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.displayName is not None:
      oprot.writeFieldBegin('displayName', TType.STRING, 6)
      oprot.writeString(self.displayName)
      oprot.writeFieldEnd()
    if self.data is not None:
      oprot.writeFieldBegin('data', TType.I32, 7)
      oprot.writeI32(self.data)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class PlayerArmor:
  """
  Represents the armor that the player is wearing

  Attributes:
   - helmet: The item in the player's helmet armor slot
   - chestplate: The item in the player's chestplate armor slot
   - leggings: The item in the player's leggings armor slot
   - boots: The item in the player's boots armor slot
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'helmet', (ItemStack, ItemStack.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'chestplate', (ItemStack, ItemStack.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'leggings', (ItemStack, ItemStack.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'boots', (ItemStack, ItemStack.thrift_spec), None, ), # 4
  )

  def __init__(self, helmet=None, chestplate=None, leggings=None, boots=None,):
    self.helmet = helmet
    self.chestplate = chestplate
    self.leggings = leggings
    self.boots = boots

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.helmet = ItemStack()
          self.helmet.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.chestplate = ItemStack()
          self.chestplate.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.leggings = ItemStack()
          self.leggings.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.boots = ItemStack()
          self.boots.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('PlayerArmor')
    if self.helmet is not None:
      oprot.writeFieldBegin('helmet', TType.STRUCT, 1)
      self.helmet.write(oprot)
      oprot.writeFieldEnd()
    if self.chestplate is not None:
      oprot.writeFieldBegin('chestplate', TType.STRUCT, 2)
      self.chestplate.write(oprot)
      oprot.writeFieldEnd()
    if self.leggings is not None:
      oprot.writeFieldBegin('leggings', TType.STRUCT, 3)
      self.leggings.write(oprot)
      oprot.writeFieldEnd()
    if self.boots is not None:
      oprot.writeFieldBegin('boots', TType.STRUCT, 4)
      self.boots.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class PlayerInventory:
  """
  Represents a player's inventory

  Attributes:
   - inventory: The items in the Player's inventory
   - itemInHand: The item(s) that the player is currently holding
   - armor: The armor that the player is currently wearing
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'inventory', (TType.STRUCT,(ItemStack, ItemStack.thrift_spec)), None, ), # 1
    (2, TType.STRUCT, 'itemInHand', (ItemStack, ItemStack.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'armor', (PlayerArmor, PlayerArmor.thrift_spec), None, ), # 3
  )

  def __init__(self, inventory=None, itemInHand=None, armor=None,):
    self.inventory = inventory
    self.itemInHand = itemInHand
    self.armor = armor

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.inventory = []
          (_etype19, _size16) = iprot.readListBegin()
          for _i20 in xrange(_size16):
            _elem21 = ItemStack()
            _elem21.read(iprot)
            self.inventory.append(_elem21)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.itemInHand = ItemStack()
          self.itemInHand.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.armor = PlayerArmor()
          self.armor.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('PlayerInventory')
    if self.inventory is not None:
      oprot.writeFieldBegin('inventory', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.inventory))
      for iter22 in self.inventory:
        iter22.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.itemInHand is not None:
      oprot.writeFieldBegin('itemInHand', TType.STRUCT, 2)
      self.itemInHand.write(oprot)
      oprot.writeFieldEnd()
    if self.armor is not None:
      oprot.writeFieldBegin('armor', TType.STRUCT, 3)
      self.armor.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Player:
  """
  Represents a player on the server

  Attributes:
   - name: The player's name
   - gamemode: The player's current gamemode
   - isSleeping: Whether the player is sleeping or not
   - isSneaking: Whether the player is sneaking or not
   - isSprinting: Whether the player is sprinting or not
   - isInVehicle: Whether the player is currently in a vehicle (minecart, boat, pig etc.)
   - xpToNextLevel: How many XP the Player needs to reach the next Level
   - level: The current Level of the player
   - ip: The IP address the player's client is currently connected on
   - isOp: Whether the Player is opped or not
   - foodLevel: How hungry the Player is in halves of chicken legs (max possible is 20)
   - health: DEPRECATED: use Player.healthDouble instead.
  How much health the Player has in halves of hearts (20 max)
   - exhaustion: How tired the player is (percentage value)
   - firstPlayed: The time/date the the player first joined (UNIX-timestamp style)
   - lastPlayed: The time/date the the player last joined (UNIX-timestamp style)
   - isBanned: If the player is currently banned from the server
   - isWhitelisted: If the player is currently on the server's whitelist
   - inventory: The current inventory of the player
   - levelProgress: Percentage progress to the next level
   - port: The port number that the player's client is currently connected on
   - location: The current location of the player
   - healthDouble: The health of the player. Use this instead of Player.health.
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'name', None, None, ), # 1
    (2, TType.I32, 'gamemode', None, None, ), # 2
    (3, TType.BOOL, 'isSleeping', None, None, ), # 3
    (4, TType.BOOL, 'isSneaking', None, None, ), # 4
    (5, TType.BOOL, 'isSprinting', None, None, ), # 5
    (6, TType.BOOL, 'isInVehicle', None, None, ), # 6
    (7, TType.I64, 'xpToNextLevel', None, None, ), # 7
    (8, TType.I32, 'level', None, None, ), # 8
    (9, TType.STRING, 'ip', None, None, ), # 9
    (10, TType.BOOL, 'isOp', None, None, ), # 10
    (11, TType.I32, 'foodLevel', None, None, ), # 11
    (12, TType.I32, 'health', None, None, ), # 12
    (13, TType.DOUBLE, 'exhaustion', None, None, ), # 13
    (14, TType.I64, 'firstPlayed', None, None, ), # 14
    (15, TType.I64, 'lastPlayed', None, None, ), # 15
    (16, TType.BOOL, 'isBanned', None, None, ), # 16
    (17, TType.BOOL, 'isWhitelisted', None, None, ), # 17
    (18, TType.STRUCT, 'inventory', (PlayerInventory, PlayerInventory.thrift_spec), None, ), # 18
    (19, TType.DOUBLE, 'levelProgress', None, None, ), # 19
    (20, TType.I32, 'port', None, None, ), # 20
    (21, TType.STRUCT, 'location', (Location, Location.thrift_spec), None, ), # 21
    (22, TType.DOUBLE, 'healthDouble', None, None, ), # 22
  )

  def __init__(self, name=None, gamemode=None, isSleeping=None, isSneaking=None, isSprinting=None, isInVehicle=None, xpToNextLevel=None, level=None, ip=None, isOp=None, foodLevel=None, health=None, exhaustion=None, firstPlayed=None, lastPlayed=None, isBanned=None, isWhitelisted=None, inventory=None, levelProgress=None, port=None, location=None, healthDouble=None,):
    self.name = name
    self.gamemode = gamemode
    self.isSleeping = isSleeping
    self.isSneaking = isSneaking
    self.isSprinting = isSprinting
    self.isInVehicle = isInVehicle
    self.xpToNextLevel = xpToNextLevel
    self.level = level
    self.ip = ip
    self.isOp = isOp
    self.foodLevel = foodLevel
    self.health = health
    self.exhaustion = exhaustion
    self.firstPlayed = firstPlayed
    self.lastPlayed = lastPlayed
    self.isBanned = isBanned
    self.isWhitelisted = isWhitelisted
    self.inventory = inventory
    self.levelProgress = levelProgress
    self.port = port
    self.location = location
    self.healthDouble = healthDouble

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.gamemode = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.isSleeping = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.isSneaking = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.isSprinting = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.BOOL:
          self.isInVehicle = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I64:
          self.xpToNextLevel = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.I32:
          self.level = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRING:
          self.ip = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.BOOL:
          self.isOp = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.I32:
          self.foodLevel = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.I32:
          self.health = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.DOUBLE:
          self.exhaustion = iprot.readDouble();
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.I64:
          self.firstPlayed = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 15:
        if ftype == TType.I64:
          self.lastPlayed = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 16:
        if ftype == TType.BOOL:
          self.isBanned = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 17:
        if ftype == TType.BOOL:
          self.isWhitelisted = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 18:
        if ftype == TType.STRUCT:
          self.inventory = PlayerInventory()
          self.inventory.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 19:
        if ftype == TType.DOUBLE:
          self.levelProgress = iprot.readDouble();
        else:
          iprot.skip(ftype)
      elif fid == 20:
        if ftype == TType.I32:
          self.port = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 21:
        if ftype == TType.STRUCT:
          self.location = Location()
          self.location.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 22:
        if ftype == TType.DOUBLE:
          self.healthDouble = iprot.readDouble();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Player')
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.gamemode is not None:
      oprot.writeFieldBegin('gamemode', TType.I32, 2)
      oprot.writeI32(self.gamemode)
      oprot.writeFieldEnd()
    if self.isSleeping is not None:
      oprot.writeFieldBegin('isSleeping', TType.BOOL, 3)
      oprot.writeBool(self.isSleeping)
      oprot.writeFieldEnd()
    if self.isSneaking is not None:
      oprot.writeFieldBegin('isSneaking', TType.BOOL, 4)
      oprot.writeBool(self.isSneaking)
      oprot.writeFieldEnd()
    if self.isSprinting is not None:
      oprot.writeFieldBegin('isSprinting', TType.BOOL, 5)
      oprot.writeBool(self.isSprinting)
      oprot.writeFieldEnd()
    if self.isInVehicle is not None:
      oprot.writeFieldBegin('isInVehicle', TType.BOOL, 6)
      oprot.writeBool(self.isInVehicle)
      oprot.writeFieldEnd()
    if self.xpToNextLevel is not None:
      oprot.writeFieldBegin('xpToNextLevel', TType.I64, 7)
      oprot.writeI64(self.xpToNextLevel)
      oprot.writeFieldEnd()
    if self.level is not None:
      oprot.writeFieldBegin('level', TType.I32, 8)
      oprot.writeI32(self.level)
      oprot.writeFieldEnd()
    if self.ip is not None:
      oprot.writeFieldBegin('ip', TType.STRING, 9)
      oprot.writeString(self.ip)
      oprot.writeFieldEnd()
    if self.isOp is not None:
      oprot.writeFieldBegin('isOp', TType.BOOL, 10)
      oprot.writeBool(self.isOp)
      oprot.writeFieldEnd()
    if self.foodLevel is not None:
      oprot.writeFieldBegin('foodLevel', TType.I32, 11)
      oprot.writeI32(self.foodLevel)
      oprot.writeFieldEnd()
    if self.health is not None:
      oprot.writeFieldBegin('health', TType.I32, 12)
      oprot.writeI32(self.health)
      oprot.writeFieldEnd()
    if self.exhaustion is not None:
      oprot.writeFieldBegin('exhaustion', TType.DOUBLE, 13)
      oprot.writeDouble(self.exhaustion)
      oprot.writeFieldEnd()
    if self.firstPlayed is not None:
      oprot.writeFieldBegin('firstPlayed', TType.I64, 14)
      oprot.writeI64(self.firstPlayed)
      oprot.writeFieldEnd()
    if self.lastPlayed is not None:
      oprot.writeFieldBegin('lastPlayed', TType.I64, 15)
      oprot.writeI64(self.lastPlayed)
      oprot.writeFieldEnd()
    if self.isBanned is not None:
      oprot.writeFieldBegin('isBanned', TType.BOOL, 16)
      oprot.writeBool(self.isBanned)
      oprot.writeFieldEnd()
    if self.isWhitelisted is not None:
      oprot.writeFieldBegin('isWhitelisted', TType.BOOL, 17)
      oprot.writeBool(self.isWhitelisted)
      oprot.writeFieldEnd()
    if self.inventory is not None:
      oprot.writeFieldBegin('inventory', TType.STRUCT, 18)
      self.inventory.write(oprot)
      oprot.writeFieldEnd()
    if self.levelProgress is not None:
      oprot.writeFieldBegin('levelProgress', TType.DOUBLE, 19)
      oprot.writeDouble(self.levelProgress)
      oprot.writeFieldEnd()
    if self.port is not None:
      oprot.writeFieldBegin('port', TType.I32, 20)
      oprot.writeI32(self.port)
      oprot.writeFieldEnd()
    if self.location is not None:
      oprot.writeFieldBegin('location', TType.STRUCT, 21)
      self.location.write(oprot)
      oprot.writeFieldEnd()
    if self.healthDouble is not None:
      oprot.writeFieldBegin('healthDouble', TType.DOUBLE, 22)
      oprot.writeDouble(self.healthDouble)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class OfflinePlayer:
  """
  Represents an offline player (or one that has never joined this server)

  Attributes:
   - name: The player's name
   - firstPlayed: The time/date the the player first joined (UNIX-timestamp style). 0 if never.
   - lastPlayed: The time/date the the player last joined (UNIX-timestamp style) 0 if never.
   - isOp: If the player is currently opped
   - isBanned: If the player is currently banned from the server
   - isWhitelisted: If the player is currently on the server's whitelist
   - player: If the player is online, more information is held in this Player object
   - hasPlayedBefore: If the player has joined the server at least once before now
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'name', None, None, ), # 1
    (2, TType.I64, 'firstPlayed', None, None, ), # 2
    (3, TType.I64, 'lastPlayed', None, None, ), # 3
    (4, TType.BOOL, 'isOp', None, None, ), # 4
    (5, TType.BOOL, 'isBanned', None, None, ), # 5
    (6, TType.BOOL, 'isWhitelisted', None, None, ), # 6
    (7, TType.STRUCT, 'player', (Player, Player.thrift_spec), None, ), # 7
    (8, TType.BOOL, 'hasPlayedBefore', None, None, ), # 8
  )

  def __init__(self, name=None, firstPlayed=None, lastPlayed=None, isOp=None, isBanned=None, isWhitelisted=None, player=None, hasPlayedBefore=None,):
    self.name = name
    self.firstPlayed = firstPlayed
    self.lastPlayed = lastPlayed
    self.isOp = isOp
    self.isBanned = isBanned
    self.isWhitelisted = isWhitelisted
    self.player = player
    self.hasPlayedBefore = hasPlayedBefore

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.firstPlayed = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.lastPlayed = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.isOp = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.isBanned = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.BOOL:
          self.isWhitelisted = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRUCT:
          self.player = Player()
          self.player.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.BOOL:
          self.hasPlayedBefore = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('OfflinePlayer')
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.firstPlayed is not None:
      oprot.writeFieldBegin('firstPlayed', TType.I64, 2)
      oprot.writeI64(self.firstPlayed)
      oprot.writeFieldEnd()
    if self.lastPlayed is not None:
      oprot.writeFieldBegin('lastPlayed', TType.I64, 3)
      oprot.writeI64(self.lastPlayed)
      oprot.writeFieldEnd()
    if self.isOp is not None:
      oprot.writeFieldBegin('isOp', TType.BOOL, 4)
      oprot.writeBool(self.isOp)
      oprot.writeFieldEnd()
    if self.isBanned is not None:
      oprot.writeFieldBegin('isBanned', TType.BOOL, 5)
      oprot.writeBool(self.isBanned)
      oprot.writeFieldEnd()
    if self.isWhitelisted is not None:
      oprot.writeFieldBegin('isWhitelisted', TType.BOOL, 6)
      oprot.writeBool(self.isWhitelisted)
      oprot.writeFieldEnd()
    if self.player is not None:
      oprot.writeFieldBegin('player', TType.STRUCT, 7)
      self.player.write(oprot)
      oprot.writeFieldEnd()
    if self.hasPlayedBefore is not None:
      oprot.writeFieldBegin('hasPlayedBefore', TType.BOOL, 8)
      oprot.writeBool(self.hasPlayedBefore)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Plugin:
  """
  Represents a server plugin. All the values that are populated into this
  object are  taken from the Plugin's server-side configuration file.

  Attributes:
   - name: The full name of the plugin
   - description: The description of the plugin
   - version: The installed version of the plugin
   - website: The website of the plugin
   - authors: The authors of the plugin
   - enabled: Whether or not the plugin is enabled
   - fileName: The name of the JAR file that this plugin was loaded from
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'name', None, None, ), # 1
    (2, TType.STRING, 'description', None, None, ), # 2
    (3, TType.STRING, 'version', None, None, ), # 3
    (4, TType.STRING, 'website', None, None, ), # 4
    (5, TType.LIST, 'authors', (TType.STRING,None), None, ), # 5
    (6, TType.BOOL, 'enabled', None, None, ), # 6
    (7, TType.STRING, 'fileName', None, None, ), # 7
  )

  def __init__(self, name=None, description=None, version=None, website=None, authors=None, enabled=None, fileName=None,):
    self.name = name
    self.description = description
    self.version = version
    self.website = website
    self.authors = authors
    self.enabled = enabled
    self.fileName = fileName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.description = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.version = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.website = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.authors = []
          (_etype26, _size23) = iprot.readListBegin()
          for _i27 in xrange(_size23):
            _elem28 = iprot.readString();
            self.authors.append(_elem28)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.BOOL:
          self.enabled = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.fileName = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Plugin')
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.description is not None:
      oprot.writeFieldBegin('description', TType.STRING, 2)
      oprot.writeString(self.description)
      oprot.writeFieldEnd()
    if self.version is not None:
      oprot.writeFieldBegin('version', TType.STRING, 3)
      oprot.writeString(self.version)
      oprot.writeFieldEnd()
    if self.website is not None:
      oprot.writeFieldBegin('website', TType.STRING, 4)
      oprot.writeString(self.website)
      oprot.writeFieldEnd()
    if self.authors is not None:
      oprot.writeFieldBegin('authors', TType.LIST, 5)
      oprot.writeListBegin(TType.STRING, len(self.authors))
      for iter29 in self.authors:
        oprot.writeString(iter29)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.enabled is not None:
      oprot.writeFieldBegin('enabled', TType.BOOL, 6)
      oprot.writeBool(self.enabled)
      oprot.writeFieldEnd()
    if self.fileName is not None:
      oprot.writeFieldBegin('fileName', TType.STRING, 7)
      oprot.writeString(self.fileName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class World:
  """
  Represents a game world

  Attributes:
   - name: The name of the world
   - time: The time of day
   - hasStorm: Whether or not there is a storm
   - isThundering: If there is thunder
   - canGenerateStructures: Whether or not structures are being generated
   - allowAnimals: Whether or not animals will spawn
   - allowMonsters: Whether or not monsters will spawn
   - difficulty: The difficulty of the world
   - environment: The environment of the world
   - fullTime: Gets the full in-game time on this world
   - weatherDuration: The remaining time in ticks of the current conditions.
   - seed: She Seed for this world.
   - isPvp: The current PVP setting for this world.
   - chunks: The number of currently loaded chunks
  @since 1.7
   - entities: The number of entities
  @since 1.7
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'name', None, None, ), # 1
    (2, TType.I64, 'time', None, None, ), # 2
    (3, TType.BOOL, 'hasStorm', None, None, ), # 3
    (4, TType.BOOL, 'isThundering', None, None, ), # 4
    (5, TType.BOOL, 'canGenerateStructures', None, None, ), # 5
    (6, TType.BOOL, 'allowAnimals', None, None, ), # 6
    (7, TType.BOOL, 'allowMonsters', None, None, ), # 7
    (8, TType.I32, 'difficulty', None, None, ), # 8
    (9, TType.I32, 'environment', None, None, ), # 9
    (10, TType.I64, 'fullTime', None, None, ), # 10
    (11, TType.I64, 'weatherDuration', None, None, ), # 11
    (12, TType.I64, 'seed', None, None, ), # 12
    (13, TType.BOOL, 'isPvp', None, None, ), # 13
    (14, TType.I32, 'chunks', None, None, ), # 14
    (15, TType.I32, 'entities', None, None, ), # 15
  )

  def __init__(self, name=None, time=None, hasStorm=None, isThundering=None, canGenerateStructures=None, allowAnimals=None, allowMonsters=None, difficulty=None, environment=None, fullTime=None, weatherDuration=None, seed=None, isPvp=None, chunks=None, entities=None,):
    self.name = name
    self.time = time
    self.hasStorm = hasStorm
    self.isThundering = isThundering
    self.canGenerateStructures = canGenerateStructures
    self.allowAnimals = allowAnimals
    self.allowMonsters = allowMonsters
    self.difficulty = difficulty
    self.environment = environment
    self.fullTime = fullTime
    self.weatherDuration = weatherDuration
    self.seed = seed
    self.isPvp = isPvp
    self.chunks = chunks
    self.entities = entities

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.time = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.hasStorm = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.isThundering = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.canGenerateStructures = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.BOOL:
          self.allowAnimals = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.BOOL:
          self.allowMonsters = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.I32:
          self.difficulty = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.I32:
          self.environment = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.I64:
          self.fullTime = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.I64:
          self.weatherDuration = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.I64:
          self.seed = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.BOOL:
          self.isPvp = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.I32:
          self.chunks = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 15:
        if ftype == TType.I32:
          self.entities = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('World')
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.time is not None:
      oprot.writeFieldBegin('time', TType.I64, 2)
      oprot.writeI64(self.time)
      oprot.writeFieldEnd()
    if self.hasStorm is not None:
      oprot.writeFieldBegin('hasStorm', TType.BOOL, 3)
      oprot.writeBool(self.hasStorm)
      oprot.writeFieldEnd()
    if self.isThundering is not None:
      oprot.writeFieldBegin('isThundering', TType.BOOL, 4)
      oprot.writeBool(self.isThundering)
      oprot.writeFieldEnd()
    if self.canGenerateStructures is not None:
      oprot.writeFieldBegin('canGenerateStructures', TType.BOOL, 5)
      oprot.writeBool(self.canGenerateStructures)
      oprot.writeFieldEnd()
    if self.allowAnimals is not None:
      oprot.writeFieldBegin('allowAnimals', TType.BOOL, 6)
      oprot.writeBool(self.allowAnimals)
      oprot.writeFieldEnd()
    if self.allowMonsters is not None:
      oprot.writeFieldBegin('allowMonsters', TType.BOOL, 7)
      oprot.writeBool(self.allowMonsters)
      oprot.writeFieldEnd()
    if self.difficulty is not None:
      oprot.writeFieldBegin('difficulty', TType.I32, 8)
      oprot.writeI32(self.difficulty)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.I32, 9)
      oprot.writeI32(self.environment)
      oprot.writeFieldEnd()
    if self.fullTime is not None:
      oprot.writeFieldBegin('fullTime', TType.I64, 10)
      oprot.writeI64(self.fullTime)
      oprot.writeFieldEnd()
    if self.weatherDuration is not None:
      oprot.writeFieldBegin('weatherDuration', TType.I64, 11)
      oprot.writeI64(self.weatherDuration)
      oprot.writeFieldEnd()
    if self.seed is not None:
      oprot.writeFieldBegin('seed', TType.I64, 12)
      oprot.writeI64(self.seed)
      oprot.writeFieldEnd()
    if self.isPvp is not None:
      oprot.writeFieldBegin('isPvp', TType.BOOL, 13)
      oprot.writeBool(self.isPvp)
      oprot.writeFieldEnd()
    if self.chunks is not None:
      oprot.writeFieldBegin('chunks', TType.I32, 14)
      oprot.writeI32(self.chunks)
      oprot.writeFieldEnd()
    if self.entities is not None:
      oprot.writeFieldBegin('entities', TType.I32, 15)
      oprot.writeI32(self.entities)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ServerHealth:
  """
  Represents a piece of information regarding the health of the server.

  @since 1.7

  Attributes:
   - id: The unique id for this piece of information.
  Valid values are:
  cpus - the number of available CPUs
  uptime - server uptime in SECONDS
  memMax - maximum useable amount of memory in KB
  memTotal - the amount of memory used in KB
  memFree - the amount of memory free in KB
   - label: The name of the piece of information. Examples would include
  "Uptime: 154235s", "Memory Usage: 500MB"
   - value: The value of the piece of information
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'id', None, None, ), # 1
    (2, TType.STRING, 'label', None, None, ), # 2
    (3, TType.STRING, 'value', None, None, ), # 3
  )

  def __init__(self, id=None, label=None, value=None,):
    self.id = id
    self.label = label
    self.value = value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.id = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.label = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.value = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ServerHealth')
    if self.id is not None:
      oprot.writeFieldBegin('id', TType.STRING, 1)
      oprot.writeString(self.id)
      oprot.writeFieldEnd()
    if self.label is not None:
      oprot.writeFieldBegin('label', TType.STRING, 2)
      oprot.writeString(self.label)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.STRING, 3)
      oprot.writeString(self.value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.id is None:
      raise TProtocol.TProtocolException(message='Required field id is unset!')
    if self.label is None:
      raise TProtocol.TProtocolException(message='Required field label is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Server:
  """
  Represents the game server.

  Attributes:
   - name: The name of the server
   - offlinePlayers: A list of all players who have ever played on this server.
   - onlinePlayers: A list of players who are currently online
   - version: The version of the server
   - bukkitVersion: The version of CraftBukkit that is running
   - maxPlayers: The max players allowed on the server
   - ip: The IP of the server (if set)
   - port: The port the server is listening on
   - allowFlight: Whether flight is allowed
   - allowNether: Whether the nether is allowed
   - allowEnd: Whether the End is allowed
   - whitelist: A list of players on the server's whitelist
   - bannedPlayers: A list of currently banned players
   - bannedIps: A list of currently banned IP addresses
   - worlds: A list of worlds currently running on the server
   - health: Information about the server's overall health; memory usage,
  cpu usage, uptime, chunk info etc.

  @since 1.7
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'name', None, None, ), # 1
    (2, TType.LIST, 'offlinePlayers', (TType.STRUCT,(OfflinePlayer, OfflinePlayer.thrift_spec)), None, ), # 2
    (3, TType.LIST, 'onlinePlayers', (TType.STRUCT,(Player, Player.thrift_spec)), None, ), # 3
    (4, TType.STRING, 'version', None, None, ), # 4
    (5, TType.STRING, 'bukkitVersion', None, None, ), # 5
    (6, TType.I32, 'maxPlayers', None, None, ), # 6
    (7, TType.STRING, 'ip', None, None, ), # 7
    (8, TType.I32, 'port', None, None, ), # 8
    (9, TType.BOOL, 'allowFlight', None, None, ), # 9
    (10, TType.BOOL, 'allowNether', None, None, ), # 10
    (11, TType.BOOL, 'allowEnd', None, None, ), # 11
    (12, TType.LIST, 'whitelist', (TType.STRUCT,(OfflinePlayer, OfflinePlayer.thrift_spec)), None, ), # 12
    (13, TType.LIST, 'bannedPlayers', (TType.STRUCT,(OfflinePlayer, OfflinePlayer.thrift_spec)), None, ), # 13
    (14, TType.LIST, 'bannedIps', (TType.STRING,None), None, ), # 14
    (15, TType.LIST, 'worlds', (TType.STRUCT,(World, World.thrift_spec)), None, ), # 15
    (16, TType.LIST, 'health', (TType.STRUCT,(ServerHealth, ServerHealth.thrift_spec)), None, ), # 16
  )

  def __init__(self, name=None, offlinePlayers=None, onlinePlayers=None, version=None, bukkitVersion=None, maxPlayers=None, ip=None, port=None, allowFlight=None, allowNether=None, allowEnd=None, whitelist=None, bannedPlayers=None, bannedIps=None, worlds=None, health=None,):
    self.name = name
    self.offlinePlayers = offlinePlayers
    self.onlinePlayers = onlinePlayers
    self.version = version
    self.bukkitVersion = bukkitVersion
    self.maxPlayers = maxPlayers
    self.ip = ip
    self.port = port
    self.allowFlight = allowFlight
    self.allowNether = allowNether
    self.allowEnd = allowEnd
    self.whitelist = whitelist
    self.bannedPlayers = bannedPlayers
    self.bannedIps = bannedIps
    self.worlds = worlds
    self.health = health

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.offlinePlayers = []
          (_etype33, _size30) = iprot.readListBegin()
          for _i34 in xrange(_size30):
            _elem35 = OfflinePlayer()
            _elem35.read(iprot)
            self.offlinePlayers.append(_elem35)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.onlinePlayers = []
          (_etype39, _size36) = iprot.readListBegin()
          for _i40 in xrange(_size36):
            _elem41 = Player()
            _elem41.read(iprot)
            self.onlinePlayers.append(_elem41)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.version = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.bukkitVersion = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.maxPlayers = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.ip = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.I32:
          self.port = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.BOOL:
          self.allowFlight = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.BOOL:
          self.allowNether = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.BOOL:
          self.allowEnd = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.LIST:
          self.whitelist = []
          (_etype45, _size42) = iprot.readListBegin()
          for _i46 in xrange(_size42):
            _elem47 = OfflinePlayer()
            _elem47.read(iprot)
            self.whitelist.append(_elem47)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.LIST:
          self.bannedPlayers = []
          (_etype51, _size48) = iprot.readListBegin()
          for _i52 in xrange(_size48):
            _elem53 = OfflinePlayer()
            _elem53.read(iprot)
            self.bannedPlayers.append(_elem53)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.LIST:
          self.bannedIps = []
          (_etype57, _size54) = iprot.readListBegin()
          for _i58 in xrange(_size54):
            _elem59 = iprot.readString();
            self.bannedIps.append(_elem59)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 15:
        if ftype == TType.LIST:
          self.worlds = []
          (_etype63, _size60) = iprot.readListBegin()
          for _i64 in xrange(_size60):
            _elem65 = World()
            _elem65.read(iprot)
            self.worlds.append(_elem65)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 16:
        if ftype == TType.LIST:
          self.health = []
          (_etype69, _size66) = iprot.readListBegin()
          for _i70 in xrange(_size66):
            _elem71 = ServerHealth()
            _elem71.read(iprot)
            self.health.append(_elem71)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Server')
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.offlinePlayers is not None:
      oprot.writeFieldBegin('offlinePlayers', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.offlinePlayers))
      for iter72 in self.offlinePlayers:
        iter72.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.onlinePlayers is not None:
      oprot.writeFieldBegin('onlinePlayers', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.onlinePlayers))
      for iter73 in self.onlinePlayers:
        iter73.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.version is not None:
      oprot.writeFieldBegin('version', TType.STRING, 4)
      oprot.writeString(self.version)
      oprot.writeFieldEnd()
    if self.bukkitVersion is not None:
      oprot.writeFieldBegin('bukkitVersion', TType.STRING, 5)
      oprot.writeString(self.bukkitVersion)
      oprot.writeFieldEnd()
    if self.maxPlayers is not None:
      oprot.writeFieldBegin('maxPlayers', TType.I32, 6)
      oprot.writeI32(self.maxPlayers)
      oprot.writeFieldEnd()
    if self.ip is not None:
      oprot.writeFieldBegin('ip', TType.STRING, 7)
      oprot.writeString(self.ip)
      oprot.writeFieldEnd()
    if self.port is not None:
      oprot.writeFieldBegin('port', TType.I32, 8)
      oprot.writeI32(self.port)
      oprot.writeFieldEnd()
    if self.allowFlight is not None:
      oprot.writeFieldBegin('allowFlight', TType.BOOL, 9)
      oprot.writeBool(self.allowFlight)
      oprot.writeFieldEnd()
    if self.allowNether is not None:
      oprot.writeFieldBegin('allowNether', TType.BOOL, 10)
      oprot.writeBool(self.allowNether)
      oprot.writeFieldEnd()
    if self.allowEnd is not None:
      oprot.writeFieldBegin('allowEnd', TType.BOOL, 11)
      oprot.writeBool(self.allowEnd)
      oprot.writeFieldEnd()
    if self.whitelist is not None:
      oprot.writeFieldBegin('whitelist', TType.LIST, 12)
      oprot.writeListBegin(TType.STRUCT, len(self.whitelist))
      for iter74 in self.whitelist:
        iter74.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.bannedPlayers is not None:
      oprot.writeFieldBegin('bannedPlayers', TType.LIST, 13)
      oprot.writeListBegin(TType.STRUCT, len(self.bannedPlayers))
      for iter75 in self.bannedPlayers:
        iter75.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.bannedIps is not None:
      oprot.writeFieldBegin('bannedIps', TType.LIST, 14)
      oprot.writeListBegin(TType.STRING, len(self.bannedIps))
      for iter76 in self.bannedIps:
        oprot.writeString(iter76)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.worlds is not None:
      oprot.writeFieldBegin('worlds', TType.LIST, 15)
      oprot.writeListBegin(TType.STRUCT, len(self.worlds))
      for iter77 in self.worlds:
        iter77.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.health is not None:
      oprot.writeFieldBegin('health', TType.LIST, 16)
      oprot.writeListBegin(TType.STRUCT, len(self.health))
      for iter78 in self.health:
        iter78.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
